<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="夜半忽闻风声">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/WWWeb/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          笔记摘要C2-IPC机制 - undefined
        
    </title>

    <link rel="canonical" href="https://ichanr.github.io/WWWeb/WWWeb/Android/笔记摘要C2-IPC机制/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/WWWeb/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/WWWeb/css/beantech.min.css">

    <link rel="stylesheet" href="/WWWeb/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/WWWeb/css/highlight.css">

    <link rel="stylesheet" href="/WWWeb/css/widget.css">

    <link rel="stylesheet" href="/WWWeb/css/rocket.css">

    <link rel="stylesheet" href="/WWWeb/css/signature.css">

    <link rel="stylesheet" href="/WWWeb/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('')
            /*post*/
        
    }
    
</style>

<header class="intro-header">
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                        </div>
                        <h1>笔记摘要C2-IPC机制</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Cai Han Rong on
                            2018-01-15
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/WWWeb/">Life in a Day</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/WWWeb/">Home</a>
                    </li>

                    

                        
                        <li>
                            <a href="/WWWeb/about/">about</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/WWWeb/categories/">分类</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="1-基础准备知识"><a href="#1-基础准备知识" class="headerlink" title="1.基础准备知识"></a>1.基础准备知识</h1><h2 id="1-1简单介绍一下什么是IPC"><a href="#1-1简单介绍一下什么是IPC" class="headerlink" title="1.1简单介绍一下什么是IPC"></a>1.1简单介绍一下什么是IPC</h2><blockquote>
<p>IPC是Inter-Process Communication的缩写，含义为进程间通信或者跨进程通信。学习IPC就是为了学习两个进程之间通信的IPC机制。</p>
<p>为了防止不同的程序之间跨界访问不属于自己的内存空间，操作系统加了一些限制在加载程序的时候就分配了内存空间，当非法访问内存空间的时候将会被系统kill掉。这个时候两个不同的进程想要通信就需要IPC这个东西了。</p>
<p>另外Android每一个进程中默认都有一个线程（UI线程），如果执行耗时的IO操作需要在开辟一个子线程，在子线程中执行耗时的业务代码。否则将会造成程序的崩溃。</p>
</blockquote>
<h2 id="1-2进程和线程的区别（看码农翻身的文章来记笔记）"><a href="#1-2进程和线程的区别（看码农翻身的文章来记笔记）" class="headerlink" title="1.2进程和线程的区别（看码农翻身的文章来记笔记）"></a>1.2进程和线程的区别（看码农翻身的文章来记笔记）</h2><p><strong>批处理系统：</strong>早期系统因为CPU只有一个并且速度很慢所以只有先把程序加载到内存中来然后让程序A从头到尾执行完毕，然后程序B接着执行。</p>
<p>后来CPU的处理速度大大超过了内存、硬盘的速度。比如程序A需要从硬盘上读取数据的时候，CPU不就空闲了？这个时候就可以让程序B来运行了。并且严格限制每个进程占用CPU的时间。</p>
<p>当CPU执行程序B的代码的时候操作系统会保存好程序A的<strong>进程控制块 -PCB</strong> （程序执行到什么指令、函数调用到什么层次了、CPU寄存器中的值等等。。），然后加载程序B的进程控制块和程序的代码。当程序A数据读取完毕的时候，就可以重新加载进程控制块和程序然后从中断处继续执行了。 进程的切换也叫上下文切换。</p>
<p>因为CPU的快速运转可以让每个程序执行几十毫秒，在我们的感觉上就是很多进程同时在运行，当然多核CPU出现后就真的可以实现多个程序同时运行了。</p>
<p><strong>进程：</strong> 那么程序的代码和他的进程控制块就被称为“进程”。</p>
<p>比如当一个进程在保存大型文件的时候，因为是IO操作所以这个进程会被暂时挂起，给我们的感觉就是界面无响应。等到保存完毕了才可以继续响应我们的操作。 所以引入了线程这个概念（线程共享进程的所有资源如地址空间、全局变量等，同时每个线程也要记住类似进程控制块那样的信息，这样就能像切换进程那样切换线程）。</p>
<p><strong>线程：</strong>把进程当成一个资源的容器，里面运行轻量级的进程（线程），线程共享进程的所有资源。线程的切换由内核来实现，因为如果由进程来实现的话，系统还是认为我们只是一个进程，对内部的线程一无所知。当某个线程执行耗时的IO操作的时候这个进程还是会被挂起。所以内核需要知道进程中线程的存在，内核需要维护一个线程表并且负责调度。</p>
<p>Android<a href="https://developer.android.google.cn/guide/components/processes-and-threads" target="_blank" rel="noopener">官方文档说明</a></p>
<h2 id="1-3-Android怎么开启多进程"><a href="#1-3-Android怎么开启多进程" class="headerlink" title="1.3 Android怎么开启多进程"></a>1.3 Android怎么开启多进程</h2><p>在AndroidManifest.xml文件中，修改四大组件的process属性。</p>
<p>第一个Activity标签中process属性中以：开头的含义是指要在当前的进程名前附加上当前的包名</p>
<p>第二个标签中，process属性是一个完整的命名方式，不会附加包名信息。</p>
<p>其中进程名以：开头的进程属于当前应用的私有进程，其他应用的组件不可以和它运行在同一个进程中，而进程名不以：开头的进程属于全局进程，其他应用可以通过Share UID方式和它运行在同一个进程中。</p>
<p>应用有相同的Share UID且签名相同就可以互相访问对方的私有数据。</p>
<p>更多的ShareUID可以参考这篇文章<a href="https://juejin.im/post/58495255ac502e006c59fc2b" target="_blank" rel="noopener">https://juejin.im/post/58495255ac502e006c59fc2b</a> 目前Linux的学的不多，所以简单知道一下就可以。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".Main2Activity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/title_activity_main2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":jc2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".LoginActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/title_activity_login"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"com.exemple.caiha.ipc.jc3"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://pb2rs4133.bkt.clouddn.com/ipc_1.jpg" alt=""></p>
<p>可以通过AndroidStudio的Logcat看到确实开启了新的进程，可以看到进程名和进程id。</p>
<h3 id="1-3-1开启多进程的好处"><a href="#1-3-1开启多进程的好处" class="headerlink" title="1.3.1开启多进程的好处"></a>1.3.1开启多进程的好处</h3><p>因为Android对每一个应用能够使用的最大内存做了限制，不同的设备能使用的内存大小也不一样，所以为了加大应用能够使用的内存空间就可以开启多进程来加大可使用的内存空间。这个时候是在两个进程中了，所以就要用到IPC。</p>
<h3 id="1-3-2模拟内存溢出"><a href="#1-3-2模拟内存溢出" class="headerlink" title="1.3.2模拟内存溢出"></a>1.3.2模拟内存溢出</h3><p>我模拟了一下内存不够的时候会发生什么事情，可以开辟一个子线程，然后不停的往集合里面写大量的数据，比如Bitmap内存占用会快一点。</p>
<p>系统抛出java.lang.OutOfMemoryError: Failed to allocate a 280364296 byte allocation with 6275072 free bytes and 205MB until OOM, max allowed footprint 193938856, growth limit 402653184，内存溢出，这样我也知道发生内存泄漏的一些原因，比如一些实例占用大量内存得不到释放。</p>
<h3 id="1-3-3开启多进程的坏处"><a href="#1-3-3开启多进程的坏处" class="headerlink" title="1.3.3开启多进程的坏处"></a>1.3.3开启多进程的坏处</h3><p><code>Android为每一个进程都分配了一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就造成了在不同的虚拟机中访问同一个类的对象会产生多分副本。</code></p>
<blockquote>
<p><code>静态成员和单列模式完全失效</code>：因为分配了一个新的独立的虚拟机，所以他们静态成员的单例模式所对应的对象是不同的。</p>
<p><code>线程同步机制失效</code>：SharedPreferences的可靠性下降：SharedPreferences不支持两个进程同时去执行写操作，它的底层是通过读写xml文件来实现的。所以并发的读写可能会导致数据丢失。</p>
<p><code>组件之间不能共享数据</code>：组件如果不同的进程，则需要IPC来进行通信。</p>
<p><code>Application会被多次创建</code>：当一个组件运行在一个新的进程中，系统要先创建一个进程并分配一个虚拟机，所以这个应用又被重新启动了，应用启动又会重新实例一个Application对象。（Application类用的是单列模式），所以一个应用只能有一个Application对象。</p>
</blockquote>
<p>所以一个应用开启了多进程在某进程中修改了一个静态类的值是不会影响另一个进程中的静态类的因为他们所在的地址不一样。</p>
<h3 id="1-3-4检验开启多进程会不会重启应用："><a href="#1-3-4检验开启多进程会不会重启应用：" class="headerlink" title="1.3.4检验开启多进程会不会重启应用："></a>1.3.4检验开启多进程会不会重启应用：</h3><p>检验开启多进程确实会重新启动该应用，需要实现一个继承自Application的类、新建几个Activity让他们跳转和设置process属性，然后再AndroidManifest.xml中修改application标签的name属性为.MyApplication，如果manifest标签的package属性没有设置的话，还需要再name属性加上那个类所在的包名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyApplication"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Log.d(TAG, <span class="string">"onCreate: 创建一次"</span>);</span><br><span class="line">        ActivityManager am = (ActivityManager) getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        List&lt;ActivityManager.RunningAppProcessInfo&gt; runningApps = am.getRunningAppProcesses();</span><br><span class="line">        <span class="keyword">if</span> (runningApps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo procInfo : runningApps) &#123;</span><br><span class="line">                <span class="keyword">if</span> (procInfo.pid == Process.myPid()) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"onCreate: 进程名为"</span> + procInfo.processName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在这个应用里面开启了两个进程，加上默认启动的那个进程那 一共就启动了三个进程</p>
<p>运行结果如下图</p>
<p><img src="http://wx4.sinaimg.cn/mw690/a5237847gy1fxigpc20eqj21g903pjsz.jpg" alt=""></p>
<p><img src="http://wx2.sinaimg.cn/mw690/a5237847gy1fxigpea3p5j21d802zmyc.jpg" alt=""></p>
<p><img src="http://wx4.sinaimg.cn/mw690/a5237847gy1fxigpgn6ocj21f903c0u7.jpg" alt=""></p>
<p>简单的看一下，就是Application类确实被实例了三次，并且打印出来的进程名不一样。OK验证完成！</p>
<h2 id="1-4Android的进程架构"><a href="#1-4Android的进程架构" class="headerlink" title="1.4Android的进程架构"></a>1.4Android的进程架构</h2><h2 id="1-5序列化"><a href="#1-5序列化" class="headerlink" title="1.5序列化"></a>1.5序列化</h2><p><code>将对象的状态信息转换为可以存储或传输的形式的过程。 在序列化期间，对象将其当前状态写入到临时或持久性存储区。 以后，可以通过从存储区中读取或反**序列化**对象的状态，重新创建该对象。</code></p>
<h3 id="1-4-1Serializable、Parcelable接口"><a href="#1-4-1Serializable、Parcelable接口" class="headerlink" title="1.4.1Serializable、Parcelable接口"></a>1.4.1Serializable、Parcelable接口</h3><p>写一个实现Serializable接口的类,并设置<code>serialVersionUID</code>的值.接下来这个类就可以通过流的形式将自己的对象发送出去,接收方可以重新读取并反序列化重现创建该对象.</p>
<p>需要注意的是,如果设置serialVersionUID的话你会发现也可以成功序列化和反序列化,但是将来如果你的字段或者属性发生了改变那么将无法正常的反序列化,它会抛出一个java.io.InvalidClassException: com.example.caiha.ipc.serialize.TestA; local class incompatible: stream classdesc serialVersionUID = 123, local class serialVersionUID = 6037855109725086113<br>W/System.err:     at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:606)类似这样的异常.</p>
<p>所以我们最好还是设置一个初始值避免以后升级这个类而无法反序列化以前的数据.就算以后新添加了一些新的属性或者方法,也可以最大限度的恢复数据不至于程序崩溃.</p>
<p>没有不手动的设置serialVersionUID的值,那么系统会自动的计算当前类的hash值并赋值给serialVersionUID.还有一点就是静态成员变量属于类并不属于对象所以不会参数序列化的过程,用transient关键字标记的成员变量不参与序列化的过程.</p>
<h3 id="1-4-2比较"><a href="#1-4-2比较" class="headerlink" title="1.4.2比较"></a>1.4.2比较</h3><table>
<thead>
<tr>
<th></th>
<th>Serializable</th>
<th>Parcelable</th>
</tr>
</thead>
<tbody>
<tr>
<td>平台</td>
<td>Java平台提供的序列化接口</td>
<td>Android提供的序列化接口</td>
</tr>
<tr>
<td>原理</td>
<td>将一个对象转换成可存储或可传输的状态，序列化后的对象可以在网络中传输也可以在存储到本地。</td>
<td>将一个对象进行分解，并且分解后的每一部分都是Intent所支持的数据类型。</td>
</tr>
<tr>
<td>优缺点</td>
<td>低效，占用大量IO资源，但是使用简单只需要实现指定接口并设置seralersionUID JAVA就会对这个对象进行序列化。</td>
<td>高效，但实现复杂,不过现在Android Studio可以自动帮我们实现。</td>
</tr>
<tr>
<td>使用场景</td>
<td>将一个对象转换为可存储或可传输的状态，序列化后的对象可存储到本地也可以通过网络进行传输。</td>
<td>内存的序列化</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;mid=2247487281&amp;idx=1&amp;sn=971778e9ef4cd926f966061640079c69&amp;chksm=97f6b185a08138933fcd30d2c10cad7825d7f51224a5f7b5f7d946ff091a1f88732d7acc7b34&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">具体用法</a> </p>
</blockquote>
<h1 id="2-Binder（重点）"><a href="#2-Binder（重点）" class="headerlink" title="2.Binder（重点）"></a>2.Binder（重点）</h1><blockquote>
<ul>
<li><code>IPC角度:</code>Binder是Android中的一种跨进程通信方式.</li>
</ul>
<ul>
<li><code>Android Framework角度:</code> Binder是ServiceManager连接各Manager(ActivityManager,WindowManager)和ManagerService的桥梁.</li>
<li><code>Android应用层:</code> Binder是客户端和服务端进行通信的媒介,当bindService的时候,服务端返回一个包含了服务端业务调用的Binder对象,通过这个BInder对象,客户端就可以获取服务端体哦那个的服务或者数据,这里的服务包括普通服务和基于AIDL的服务.</li>
<li>学习资料：<a href="https://zhuanlan.zhihu.com/p/35519585" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35519585</a></li>
</ul>
</blockquote>
<h2 id="2-1特性"><a href="#2-1特性" class="headerlink" title="2.1特性"></a>2.1特性</h2><table>
<thead>
<tr>
<th>IPC方式</th>
<th>数据拷贝次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享内存</td>
<td>0</td>
</tr>
<tr>
<td>Binder</td>
<td>1</td>
</tr>
<tr>
<td>Socket/管道/队列</td>
<td>2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Binder的特性</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>安全性</td>
<td>给每个APP分配一个UID,UID是鉴别</td>
</tr>
<tr>
<td>稳定性</td>
<td>基于C/S架构，职责明确，架构清晰</td>
</tr>
<tr>
<td>性能</td>
<td>数据只需拷贝一次</td>
</tr>
</tbody>
</table>
<h2 id="2-2原理"><a href="#2-2原理" class="headerlink" title="2.2原理"></a>2.2原理</h2><blockquote>
<p><code>详细解释：</code><a href="https://zhuanlan.zhihu.com/p/35519585" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35519585</a></p>
<p><code>简单总结上面的文章：</code></p>
<p><code>Binder的诞生:</code>Linux内核提供了几种跨进程通信的方式，但是因为安全和性能的关系，Android使用了另一种新的进程通信方式。</p>
<p><code>为什么要用到IPC：</code>因为进程间是分隔开的，进程A是不能直接访问进程B的数据，要进行进程间的数据通信就需要用到进程间的通信机制。</p>
<p>因为Binder是运行在内核空间的，可以访问受保护的内存空间。我们通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p>大致的进程通信过程为：</p>
<ol>
<li>首先，一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ol>
</blockquote>
<h1 id="3-Android中的IPC方式"><a href="#3-Android中的IPC方式" class="headerlink" title="3. Android中的IPC方式"></a>3. Android中的IPC方式</h1><table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
<th>具体用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bundle</td>
<td>简单易用</td>
<td>只能传输Bundle支持的数据类型</td>
<td>四大组件的j进程间通信</td>
<td></td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合在高并发的场景下使用，并且无法做到进程间的即时通信。</td>
<td>无并发访问情形，交换简单的数据，实时性不高的场景。</td>
<td></td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大，支持一对多并发通信，，支持实时通信。</td>
<td>使用复杂，需要处理好线程同步</td>
<td>一对多通信且有RPC要求</td>
<td></td>
</tr>
<tr>
<td>Messenger</td>
<td>功能一般，支持一对多串行通信，支持实时通信。</td>
<td>不能很好的处理高并发情形，不支持RPC,数据通过Message进行传输,因此只能传输Bundle支持的数据类型</td>
<td>低并发的一对多即时通信，无RPC要求，或者无需返回结果的RPC需求</td>
<td></td>
</tr>
<tr>
<td>ContentProvider</td>
<td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法扩展其他操作。</td>
<td>可以理解为受约束的AIDL，主要提供对数据源的CRUD操作</td>
<td>一对多的进程间的数据交换</td>
<td></td>
</tr>
<tr>
<td>Socket</td>
<td>功能强大，可通过网络传输字节流，支持一对多并发实时通信。</td>
<td>实现细节稍微有点繁琐，不支持直接的RPC</td>
<td>网络数据交换</td>
</tr>
</tbody>
</table>
<h2 id="1-Bundle"><a href="#1-Bundle" class="headerlink" title="1. Bundle"></a>1. Bundle</h2><blockquote>
<p>通过Intent传递Bundle数据，传递的元素除了它支持的基本类型其他的类型要实现Parcelable接口中的方法才可以被序列化并传递。</p>
</blockquote>
<h2 id="2-使用文件共享"><a href="#2-使用文件共享" class="headerlink" title="2.使用文件共享"></a>2.使用文件共享</h2><blockquote>
<p>两个进程通过读写同一个文件来交换数据，同时还可以序列化一个对象到文件中，具体的在Serializable接口中有说明。只不过发生并发读写很容易数据很容易错乱，所以还是少用比较好。</p>
<p>SharedPreferences是Android提供的轻量级存储方案通过键值对的方式来存储数据，底层它采用XML来存储键值对。因为系统对它的读写有一个缓存策略，即内存中有一份SharedPreferences文件的缓存因此在多进程模式下系统对他的读写就变得可靠。阅读Google的API也说了不支持多进程的使用使用SharedPreferences。</p>
<p>用法：<a href="https://developer.android.google.cn/training/data-storage/shared-preferences" target="_blank" rel="noopener">https://developer.android.google.cn/training/data-storage/shared-preferences</a></p>
</blockquote>
<h2 id="3-Messenger"><a href="#3-Messenger" class="headerlink" title="3.Messenger"></a>3.Messenger</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>通过它可以在不同进程中传递Message对象，在Message中放入需要传递的数据就可以通过Messenger来在各进程间传递了。</p>
<p>Messenger是一种轻量级的IPC方案，底层实现是AIDL。</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote>
<p>Messenger内部的IBinder是通过Handle传递进来的，通过构造方法可见一斑，它的底层实现还是AIDL只是经过了一点封装。</p>
<p><strong>服务端：</strong> 在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler，通过它来创建一个Messenger对象，然后再Service的onBind方法中返回Messenger对象的Binder即可。</p>
<p><strong>客户端：</strong> 先绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger对象。如果需要服务端可以回应客户端的话，把当前的Messenger对象赋值给在Message中的 replyTo变量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">messengerHandle</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">"handleMessage: 服务端收到客户端发送的请求，附加参数为"</span>+msg.arg1);</span><br><span class="line">                    Messenger messenger=msg.replyTo;</span><br><span class="line">                    Message message=Message.obtain();</span><br><span class="line">                    message.what=<span class="number">1</span>;</span><br><span class="line">                    message.arg1=<span class="number">123</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        messenger.send(message);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> messengerHandle());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Return the communication channel to the service.</span></span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</span><br><span class="line">        bindService(intent, mServiceConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandle</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">"handleMessage: 客户端接收到服务端的返回数据"</span> + msg.arg1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger mMessenger;</span><br><span class="line">    <span class="keyword">private</span> Messenger mMessenger2 = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandle());</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mMessenger = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            Message message = <span class="keyword">new</span> Message();</span><br><span class="line">            message.what = <span class="number">1</span>;</span><br><span class="line">            message.arg1 = <span class="number">369</span>;</span><br><span class="line">            message.replyTo = mMessenger2;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mMessenger.send(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":other"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过上面代码测试，确实能够实现进程间的通信。</p>
<h2 id="4-使用AIDL"><a href="#4-使用AIDL" class="headerlink" title="4.使用AIDL"></a><a href="https://developer.android.google.cn/guide/components/aidl#Expose" target="_blank" rel="noopener">4.使用AIDL</a></h2><h3 id="1-创建-aidl-文件"><a href="#1-创建-aidl-文件" class="headerlink" title="1. 创建 .aidl 文件"></a>1. 创建 .aidl 文件</h3><blockquote>
<p>AIDL 使用简单语法，使您能通过可带参数和返回值的一个或多个方法来声明接口。 参数和返回值可以是任意类型，甚至可以是其他 AIDL 生成的接口。</p>
<p>您必须使用 Java 编程语言构建 <code>.aidl</code> 文件。每个 <code>.aidl</code> 文件都必须定义单个接口，并且只需包含接口声明和方法签名。</p>
<p>默认情况下，AIDL 支持下列数据类型：</p>
<ul>
<li><p>Java 编程语言中的所有原语类型（如 <code>int</code>、<code>long</code>、<code>char</code>、<code>boolean</code> 等等）String、CharSequence、List、Map，其中集合中的子元素需要是以上的基本元素。</p>
<p>*<code>概况一下:</code>  就是除了以上的基础类型 集合内部的子元素想要是其他类型想要在AIDL中使用的话，需要先建立一个与类名相同的AIDL文件，并以 parcelable 类名；来声明，比如 <code>parcelable Book;</code></p>
<p>然后在要使用的AIDL文件中 <code>import 包名.aidl声明类型的文件名</code></p>
</li>
</ul>
</blockquote>
<h3 id="2-实现接口"><a href="#2-实现接口" class="headerlink" title="2.实现接口"></a>2.实现接口</h3><blockquote>
<p>当您开发应用时，Android SDK 工具会生成一个以 <code>.aidl</code> 文件命名的 <code>.java</code> 接口文件。生成的接口包括一个名为 <code>Stub</code> 的子类，这个子类是其父接口（例如，<code>YourInterface.Stub</code>）的抽象实现，用于声明 <code>.aidl</code> 文件中的所有方法。</p>
</blockquote>
<h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><blockquote>
<p>写完.aidl文件后重新构建该项目，Android SDK会在gen目录下自动生成一个和 <em>.aidl 同名的 </em>.java文件，就分析这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">&gt;  	</span><br><span class="line">&gt;     <span class="comment">//内部类Stub 实际上就是一个Binder类，当客户端和服务端处于同以进程时不会走transact过程，反之就会走。</span></span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">caiha</span>.<span class="title">ipc5</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">&gt;         <span class="comment">//标识符，Binder的唯一标识</span></span><br><span class="line">&gt;         <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.example.caiha.ipc5.IBookManager"</span>;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&gt;         <span class="comment">//用于将服务端的Binder转换成客户端所需的AIDL接口类型对象，这种过程时区分进程的，C/S在同一进程下返回的时服务端的Stub对象本身，反之返回封装后的Stub.proxy对象。（分析一下方法就知道了。）</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;&#125;</span><br><span class="line">&gt;         </span><br><span class="line">&gt; 		<span class="comment">//用于返回当前Binder对象。</span></span><br><span class="line">&gt;         <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&gt; 		</span><br><span class="line">&gt;         <span class="comment">//该方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法处理。服务端通过code来确定服务端请求哪个方法，从data中获取目标方法所需的参数。reply用于写入将要返回给客户端的数据。 最后如果返回false的话，客户端的请求会失败，可以利用这个特性来做一些权限验证。</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span>&#123;&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">caiha</span>.<span class="title">ipc5</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">&gt;             <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">&gt; </span><br><span class="line">&gt;             Proxy(android.os.IBinder remote) &#123;&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&gt; 			</span><br><span class="line">&gt;             </span><br><span class="line">&gt;             <span class="comment">//外部两个方法的具体实现，通过父类Binder的transact方法调用到Binder的onTransact方法。至此整个流程我就都知道了。</span></span><br><span class="line">&gt;             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.caiha.ipc5.aaa.Book book)</span>   </span>&#123;&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="keyword">public</span> java.util.List&lt;com.example.caiha.ipc5.aaa.Book&gt; getBookList() &#123;&#125;</span><br><span class="line">&gt;             </span><br><span class="line">&gt; 		<span class="comment">//两个两个int常量可以用来标识在transact过程中客户端到底请求的是哪个方法。</span></span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; 	</span><br><span class="line">&gt;         </span><br><span class="line">&gt;        <span class="comment">//下面声明的两个方法是在我们的aidl文件中定义的。</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.caiha.ipc5.aaa.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">public</span> java.util.List&lt;com.example.caiha.ipc5.aaa.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>以上代码也可以手动写出来，AIDL不过是简化了我们的流程而已。</p>
</blockquote>
<h3 id="4-给Binder设置死亡代理"><a href="#4-给Binder设置死亡代理" class="headerlink" title="4.给Binder设置死亡代理"></a>4.给Binder设置死亡代理</h3><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">private</span> IBinder.DeathRecipient mBinderPoolDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         Log.w(TAG, <span class="string">"啊 服务端死掉了: "</span>);</span><br><span class="line">&gt;         Binder对象.asBinder().unlinkToDeath(mBinderPoolDeathRecipient, <span class="number">0</span>);</span><br><span class="line">&gt;         Binder对象 = <span class="keyword">null</span>;</span><br><span class="line">&gt;         connectBinderPoolService();</span><br><span class="line">&gt;         <span class="comment">//当服务端的出现以外停止的时候该方法会被调用，客户可以在这里进行重连的处理。</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/WWWeb/Hexo/Hexo使用记录导航/" data-toggle="tooltip" data-placement="top" title="Hexo使用记录">&larr; Previous Post</a>
                        </li>
                    
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>










    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Cai Han Rong 2019 
                    <br>
                    Theme by <a href="http://beantech.org">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com">胡伟煌</a> | 
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=huweihuang&repo=hexo-theme-huweihuang&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/WWWeb/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/WWWeb/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/WWWeb/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://ichanr.github.io/WWWeb/WWWeb/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://ichanr.github.io/WWWeb/WWWeb/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
