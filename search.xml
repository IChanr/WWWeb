<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 学习记录导航页]]></title>
    <url>%2FWWWeb%2FAndroid%2FAndroid-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%AF%BC%E8%88%AA%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[当然还有一些没整理好没发上来。 Android Studio疑难杂症：Androoid Studio 踩坑记录 Android基础：四大组件-服务 四大组件-广播 Android进阶：Android开发艺术探索概要1–Activity的生命周期和启动模式 Android开发艺术探索概要2–IPC机制]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[“日常迷茫”]]></title>
    <url>%2FWWWeb%2Funcategorized%2F%E2%80%9C%E6%97%A5%E5%B8%B8%E8%BF%B7%E8%8C%AB%E2%80%9D%2F</url>
    <content type="text"><![CDATA[2018-11-21 学习IPC 安卓怎么使用Binder驱动程序来进行进程间的通信的？ 需要学习Linux内核怎么加载驱动，jvm怎么调用c/c++的。 2018-11-22 今晚我又看了一晚上的Binder原理的文章，了解了内核空间和用户空间，Linux提供的IPC更多的是从用户空间复制到内核空间再复制到另一个用户空间中，Binder可以从内核空间中映射到用户空间中，所以可以减少一个复制操作。 文章都说Service都注册到ServiceManager中，SM是通过系统初始化生成Binder的。然后他们都是两个不同的进程，那他们怎么通过系统调用Binder是我一直搞不懂的,看了gityuan的文章说（binder涉及的层次跨度比较大,知识量比较广, 建议大家先知道binder是用于进程间通信,有个大致概念就可以.先去学习系统基本知识,等后面有一定功力再进一步深入研究Binder.） 所以我就当作Binder可以跨进程一个神奇类了，Android自动帮我们完成对Binder驱动程序的调用。 Binder的源码的原理我等基本功可以了再来学(c和linux内核学习完成后) 不过我要怎么假设这个Binder呢？ 我只知道bindService后通过ServiceConnection类来返回Binder(Binder由服务注册的时候保存到ServiceManager中的，具体由系统实现)我们通过这个Binder来进行通信。 2018-11-23 开始懂得了，好好学习应用层的知识吧。 2018-11-24 现在学习方向就是跟着Android开发艺术探索学习,遇到不清不楚的都写个文章记录下来.把握流程后面再来深入学习原理.]]></content>
  </entry>
  <entry>
    <title><![CDATA[反射和代理的运用]]></title>
    <url>%2FWWWeb%2Funcategorized%2F%E5%8F%8D%E5%B0%84%E5%92%8C%E4%BB%A3%E7%90%86%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[## 反射： Java核心技术卷1-能够分析类能力的程序称为反射。 具体一点，在我看来就时可以通过反射来获取某个对象的所属类、属性、拥有那些方法等。 Class类 在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识，这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。 保存这些信息的类被称为Class，例如Object类中的getClass()方法将会返回一个Class类型的实例。里面包含这个特定类的属性。 如何获取Class对象？ *.getClass(); *.forName(“包名.类名”)； 类名.class; 12345678&gt;FlectTest flectTest = new FlectTest("name", 18, "boy", "location");&gt;Class c1=flectTest.getClass();&gt;Class c2=Class.forName("reflect.FlectTest");&gt;Class c3=FlectTest.class;&gt;System.out.println(c1);&gt;System.out.println(c2);&gt;System.out.println(c3);&gt; 通过上面的代码可以正确的获取到Class对象。 注意：一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如int不是类，但int.class是一个Class的类型对象。（所有的类都是Object的子类，Object提供了获取当前类的Class对象） 我的理解是：通过Class我们可以获取到类的属性、方法 常用方法 方法 描述 getMethod getMethods 返回一个包含Method对象的数组（包含父类，超类的公有域） getField getFields 返回一个包含Field对象的数组（包含父类，超类的公有域） getConstructor getConstructors 返回一个包含Constructors对象的数组（包含父类，超类的公有域） getDeclaredFields 。。。。私有域也可以获取到，声明为 private 需要注意的是Java的反射机制受制于访问控制，对于私有域只能查看对象有哪些私有域，而不能读取他们的值。 否则将会导致IllegalAccessException，下面的代码验证了这个结果。 1234567891011&gt;FlectTest flectTest = new FlectTest("name", 18, "boy", "location");&gt; Class c=flectTest.getClass();&gt; try &#123;&gt; Field field = c.getDeclaredField("name");&gt; System.out.println(field.get(c));&gt; &#125; catch (NoSuchFieldException e) &#123;&gt; e.printStackTrace();&gt; &#125; catch (IllegalAccessException e) &#123;&gt; e.printStackTrace();&gt; &#125;&gt; 代理： 在不改变已有代码的结构的情况下增强或控制对象的行为。 通过以下代码，实现记录登录时间 123456&gt;package proxy;&gt;&gt;public interface Login &#123;&gt; void startLogin(String userName,String passWord);&gt;&#125;&gt; 1234567891011121314&gt;package proxy;&gt;&gt;public class LoginImpl implements Login &#123;&gt; @Override&gt; public void startLogin(String userName, String passWord) &#123;&gt; if (userName.equals("admin") &amp;&amp; passWord.equals("123456")) &#123;&gt; System.out.println("登录成功");&gt; &#125;else &#123;&gt; System.out.println("登录失败");&gt; &#125;&gt; &#125;&gt;&#125;&gt;&gt; 静态代理：12345678910111213141516package proxy;import java.util.Date;public class LoginStaticProxy implements Login&#123; private LoginImpl mLogin; @Override public void startLogin(String userName, String passWord) &#123; getLoginTime(); mLogin.startLogin("admin","123456"); &#125; public void getLoginTime()&#123; System.out.println(new Date()); &#125;&#125; 通过以上代码，我们只需要在其他地方调用这个代理类就可以实现记录登录时间和进行登录操作了。无需对原有的实现类进行修改，瞬间就美观了很多。 不过也很烦躁啊，如果需要很多种不同的功能，比如我们现在不要获取它的登录时间想要获取它的登录地点，那不就又要建立一个代理类了？ 这个时候动态代理出现了。 动态代理：1234567891011121314151617181920212223package proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Date;public class DynamicProxy implements InvocationHandler &#123; private Object mObject; public DynamicProxy(Object object) &#123; mObject = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; getLoginTime(); Object result=method.invoke(mObject, args); return result; &#125; private void getLoginTime()&#123; System.out.println(new Date()); &#125;&#125; 1234567891011121314package proxy;import java.lang.reflect.Proxy;public class LoginMain &#123; public static void main(String[] args) &#123; DynamicProxy dynamicProxy = new DynamicProxy(login); Login loginProxy = (Login) Proxy.newProxyInstance(login.getClass().getClassLoader(), login.getClass().getInterfaces(), dynamicProxy); loginProxy.startLogin("admin","123456"); &#125;&#125; 通过动态代理，你就不再需要新建很多的代理类了，jdk自带的Proxy类已经自动帮我们生成好了。 而且我们还可以在InvocationHandler中的invoke的方法中对某些要执行的方法进行拦截或者验证，实现新功能。 参考文章：https://my.oschina.net/huangyong/blog/159788 参考书籍：设计模式之禅]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android进阶-IPC机制]]></title>
    <url>%2FWWWeb%2FAndroid%2FAndroid%E8%BF%9B%E9%98%B6-IPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[IPC基础概念 IPC是Inter-Process Communication的缩写，含义为进程间通信或者跨进程通信。 线程的进程的区别 线程：CPU调度的最小单元，同时线程是一种有限的系统资源 进程：一般指一个执行单元（一个程序或者应用） Android中的多进程 Manifest.xml中的activity标签设置属性 android:process=”*” 星号内容为进程的名称 如果我们有三个Activity，其中两个指定了不同的process属性的话，那么他们将运行在不同的进程中，不指定process则运行在默认进程中默认为包名。 12345678910&gt; &lt;activity android:name=".MainActivity"/&gt;&gt; &lt;activity&gt; android:name=".Main2Activity"&gt; android:label="@string/title_activity_main2"&gt; android:process=":jc2" /&gt;&gt; &lt;activity&gt; android:name=".LoginActivity"&gt; android:label="@string/title_activity_login"&gt; android:process="com.exemple.caiha.ipc.jc3" /&gt;&gt; :jc2 中的：表示前面自动加上进程名，而且表示该进程是当前应用的私有进程，其他应用的组件不可以和它泡在同一个进程中。其他的则是全局进程，可以通过ShareUID跑在同一个进程中。 &gt;UID: Android会为每一个应用分配一个唯一的UID，具有相同UID的应用cky共享数据。 &gt; &gt;ShareUID: 两个应用具有相同的ShareUID并且签名相同才可以跑在同一个进程中。 通过Logcat我们可以看到确实启动了三个进程，如图。 也可以用shell来查看命令为：adb shell ps 多进程带来的影响 最大的影响就是组件之间不能共享数据，线程同步机制失效，Application会被多次创建。 因为Android中如果让一个组件运行在一个新的进程中，那么系统创建一个新的虚拟机给这个进程运行，我们知道默认一个应用就运行在一个虚拟机当中，他们互不影响。如果我们当某个组件运行在新进程中那么系统会在新的虚拟机中重新启动这个应用。(每个应用都有一个Application,我们可以通过Application的onCreate()方法来检验 ) 新建一个继承自Application的类并重写onCreate()方法 12345678910111213141516171819202122232425&gt; public class MyApplication extends Application &#123;&gt; private static final String TAG = "MyApplication";&gt; &gt; @Override&gt; public void onCreate() &#123;&gt; super.onCreate();&gt; Log.d(TAG, "onCreate: 当前应用被创建一次");&gt; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;&gt; Log.d(TAG, "onCreate: 进程名：" + getProcessName());&gt; &#125; else &#123;&gt; ActivityManager am = (ActivityManager) getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);&gt; List&lt;ActivityManager.RunningAppProcessInfo&gt; runningApps = am.getRunningAppProcesses();&gt; if (runningApps != null) &#123;&gt; for (ActivityManager.RunningAppProcessInfo procInfo : runningApps) &#123;&gt; if (procInfo.pid == Process.myPid()) &#123;&gt; Log.d(TAG, "onCreate: " + procInfo.processName);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; &#125;&gt; &gt; &#125;&gt; 在Manifest.xml中 修改application标签中的属性 android:name=”.MyApplication” 让活动跳转之后查看Logcat的输出信息！ 可以看到确实是新建了3个Application，因为一个程序只有一个实例，所以每开启一个新的进程都会启动这个应用在另一个新的虚拟机中。验证成功！ 正因为多进程带来的问题，所以我们要学习一些跨进程通信的方式比如Intent传递数据、共享文件、SharedPreferences、基于Binder的Messenger和AIDL以及Socket等方式。 Application类（单列模式） 每个应用在运行时，首先创建的就是Application类的对象。（有且只有一个） 我们可以通过继承Application类来实现我们想要的功能。 AndroidManifest.xml中的application标签中android:name=”.MyApplication”的作用是：启动应用程序进程时，将在任何应用程序的组件之前实例化此类。在没有设置的情况下，Android使用基本Application类作为实例。 序列化对象为什么要序列化对象？ 序列化对象可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows 机器上创建一个对象，对其序列化，然后通过网络发给一台 Unix 机器，然后在那里准确无误地重新生成对象。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。 对象的序列化也是 Java Beans 必需的，后者由Java 1.1 引入。使用一个Bean 时，它的状态信息通常在设计期间配置好。程序启动以后，这种状态信息必须保存下来，以便程序启动以后恢复；具体工作由对象序列化完成。对象的序列化处理非常简单，只需对象实现了 Serializable 接口即可（该接口仅是一个标记，没有方法）。Java会自动帮我们进行序列化。 额，反序列化后对象的内容都是一样的，对象是新创建的。 Serializable接口 Serializable是Java所提供的一个序列化接口，它是一个空接口，它可以为对象提供标准的序列化和反序列化操作。使用方法十分简单只要实现Serializable接口并在类中定义一个long类型的常量serialVersionUID就行了。 如果没有设置serialVersionUID你会发现也可以实现序列化，这又是为什么呢？ 原来序列化的工作是由系统完成的（通过Object’Output/Input’Stream来实现序列化），反序列化的时候会拿数据中的serialVersionUID和类中的serialVersionUID进行比较，如果不相同（表示发生了某些变化）就会反序列化失败。 如果没有指定serialVersionUID系统默认会通过计算类的hash值来赋值给它，这样的话一旦类的属性发生变化 那就gg了，什么数据都得不到，设置了serialVersionUID好歹还可以恢复一些有的属性。 12345&gt; public class Test implements Serializable &#123;&gt; public static final long serialVersionUID = 515646L;&gt; //简单实现序列化&gt; &#125;&gt; 序列化和反序列化过程 1234567&gt; Test test=new Test("username", "password");&gt; ObjectOutputStream objectOutputStream=new ObjectOutputStream(new FileOutputStream("cache.txt"));&gt; objectOutputStream.writeObject(test);&gt; &gt; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("cache.txt"));&gt; Test getTest= (Test) objectInputStream.readObject();&gt; Parcelable接口 实现类 123456789101112131415161718192021222324252627282930313233&gt; public class Test implements Parcelable &#123;&gt; private String userName;&gt; private String passWord;&gt; &gt; protected Test(Parcel in) &#123;&gt; userName = in.readString();&gt; passWord = in.readString();&gt; &#125;&gt; &gt; public static final Creator&lt;Test&gt; CREATOR = new Creator&lt;Test&gt;() &#123;&gt; @Override&gt; public Test createFromParcel(Parcel in) &#123;&gt; return new Test(in);&gt; &#125;&gt; &gt; @Override&gt; public Test[] newArray(int size) &#123;&gt; return new Test[size];&gt; &#125;&gt; &#125;;&gt; &gt; @Override&gt; public int describeContents() &#123;&gt; return 0;&gt; &#125;&gt; &gt; @Override&gt; public void writeToParcel(Parcel dest, int flags) &#123;&gt; dest.writeString(userName);&gt; dest.writeString(passWord);&gt; &#125;&gt; &#125;&gt; 序列化和反序列化的方法和上面的一样。 小声bb： 也可以使用json来读写对象那 ,觉得解析json很麻烦的话还可以使用Google的gso’n啊！ 使用AIDL AIDL是一个缩写，全称是Android Interface Definition Language，也就是Android接口定义语言。 通过使用AIDL，Android Studio可以根据这个文件自动生成类。 文件类型：用AIDL书写的文件的后缀是 .aidl，而不是 .java。 导包：在Java中，处于同一个包下面的类是不用导包的，但是在AIDL中除了8个基本类型、String、CharSequence、List、Map不需要导包，其他的都需要手动的进行导包。(需要注意的是集合里面的元素也要是基本类型或者可以序列化) 两种AIDL文件： 一类是：定义parcelable对象，以供其他AIDL文件使用AIDL中不支持的数据类型 另一类：定义接口中有哪些方法，以供系统使用来完成跨进程通信。 可以看出他们都是在定义某些东西，而不是具体的实现，实现类由AndroidStudio帮我们生成。所以AIDL才叫Android接口定义语言。 根据Android开发艺术探索的列子来看 1234567891011121314151617181920212223242526272829&gt; // Book.aidl 第一个文件&gt; package com.example.caiha.ipc.aidl;&gt; //包名要和Book.java一样。&gt; // Declare any non-default types here with import statements&gt; &gt; //引入一个序列化对象Book&gt; parcelable Book;&gt; &gt; &gt; &gt; &gt; &gt; // IBookManager.aidl 第二个文件&gt; package com.example.caiha.ipc.aidl;&gt; &gt; //导入需要的非基础类型的包&gt; import com.example.caiha.ipc.aidl.Book;&gt; interface IBookManager &#123;&gt; //返回值不需要什么东西，不管什么类型。&gt; List&lt;Book&gt;getBookList();&gt; &gt; //传参数时除了基本类型和String,都要在前面加上定向tag&gt; void addBook(in Book book);&gt; //里面的in很奇怪是吧？ 这个表示数据的流向&gt; //in表示数据只能从客户端流向服务端，out表示数据只能从服务端流向客户端，&gt; //inout 表示数据可以在两端流动。&gt; &#125;&gt; &gt; 通过AIDL会在gen目录下的相应包名里面自动实现IBookManager接口，内部类为Binder。 自动生成的IBookManger结构为 AIDL中声明的方法+内部类(Binder子类) 内部类中：又有一个代理类 实现了IBookManger的方法 1234&gt; Stub内部类&gt; Proxy内部类&gt; 两个方法的声明&gt; Binder 效率： Android是基于Linux内核开发的，Linux本身提供了很多进程间通信的机制，比如管道、信号、消息队列、共享内存、Socket等，但是因为效率的问题，Android自己开发了一套新的进程间通信机制–Binder，与传统的进程间通信机制相对比，Binder来传输数据时只需要执行一次复制操作，所以它效率更高而且更加节省内存空间。 机制： Binder进程间的通信机制是在OpenBinder的基础上改造实现的，它采用CS通信方式。提供服务的进程称为Server进程，访问服务进程称为Client进程，Binder维护一个Binder线程池来处理客户端和服务端的通信请求。 * Binder进程： Server进程和Client进程的通信主要通过运行在内核控件的Binder驱动程序来进行,Binder驱动程序向用户空间暴露了一个设备文件/dev/binder，使得进程可以间接的通过它来建立通信通道。 Server组件在启动时会把自动注册到一个Service Manager 组件中，以便Client组件可以通过Service Manager组件找到它。Service Manager组件被称为进程间通信机制的上下文管理者，由于他也要和普通的Serve/Client进程进行通信，也可也把它看作是一个特殊Service组件。 访问驱动程序： Client，Service和Service Manager运行在用户空间，Binder驱动程序运行在内核空间中，其中Service Manager和Binder驱动程序由系统负责提供(通过系统调用open、mmap、ioctl来访问设备文件/dev/binder)从而实现与Binder驱动程序的交互。 对于我这个初学者来说，我就是简单的认为只要继承自Binder类，系统都会自动帮我们实现与Binder驱动程序的交互。 我们可以使用AIDL来自动生成Binder的实现类，Binder实现了IBinder接口。 从IPC角度：Binder是Android中一种跨进程通信的方式。 从Android Framework角度：Binder是ServiceManager连接各种Manger(ActivityManager、WindowManger)和相应ManagerService的桥梁。 从Android应用层角度：Binder是客户端和服务端进行通信的媒介。bindService的时候返回一个包含服务端业务调用的Binder对象，通过这个对象客户端可以获取服务端提供的服务或者数据。(普通服务、基于AIDL的服务) 通过AIDL来分析Binder的工作过程。 我们是通过AIDL来生成Binder类 跨进程通信方式Messenger小案例 先新建一个服务端和一个客户端，在Manifest.xml中给服务设置process属性，让他运行在另一个进程中，然后我们就可以进行进程间的通信验证了。 12345678910111213141516171819202122232425262728293031323334353637public class MyService extends Service &#123; private static final String TAG = "MyService"; private static class messagerHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; //super.handleMessage(msg); 因为父类的实现也是空的，所以有时候删除调用父类的某些方法也是可以的 switch (msg.what) &#123; case 1: Log.d(TAG, "handleMessage: 1"+"不管怎么说，服务端就是受到了信息"); break; default: break; &#125; &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate: "); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand: "); return super.onStartCommand(intent, flags, startId); &#125; private final Messenger mMessenger = new Messenger(new messagerHandler()); @Nullable @Override public IBinder onBind(Intent intent) &#123; return mMessenger.getBinder(); &#125;&#125; 上面的服务端使用Messenger来实现进程间的通信，Messenger的底层还是Binder 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; private Messenger mMessenger; private ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mMessenger = new Messenger(service); Message message = Message.obtain(null, 1); try &#123; mMessenger.send(message); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, MyService.class); startService(intent); bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(mServiceConnection); &#125;&#125; Activity的bindService实际上内部已经自动帮我们启动服务，并在ServiceConnection的onServiceConnected方法中返回服务持有的Binder,我们就可以在这里面实例化Messenger类，通过这个Binder我们就可以与服务进行通信了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql安装记录]]></title>
    <url>%2FWWWeb%2Funcategorized%2Fmysql%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[下载 先到 https://dev.mysql.com/downloads/mysql/ 下载mysql的压缩包，下载完成以后解压到本地目录下面。 修改配置 …\mysql-8.0.13-winx64\bin 目录下新建一个my.ini配置文件，内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142&gt; &gt; #设置3306端口&gt; port=3306&gt; &gt; &gt; #设置mysql的安装目录&gt; basedir=D:\\WorkLibrary\\mysql-8.0.13-winx64\\mysql-8.0.13-winx64&gt; &gt; ?# 切记此处一定要用双斜杠\\，单斜杠我这里会出错。&gt; &gt; #设置mysql数据库的数据的存放目录&gt; &gt; datadir=D:\\WorkLibrary\\mysql-8.0.13-winx64\\mysql-8.0.13-winx64\\Data?&gt; &gt; ?# 此处同上&gt; &gt; #允许最大连接数&gt; &gt; max_connections=200&gt; &gt; #允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10&gt; &gt; #服务端使用的字符集默认为&gt; &gt; UTF8character-set-server=utf8&gt; &gt; #创建新表时将使用的默认存储引擎&gt; &gt; default-storage-engine=INNODB&gt; &gt; #默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password&gt; &gt; [mysql]&gt; &gt; #设置mysql客户端默认字符集&gt; &gt; default-character-set=utf8[client]&gt; &gt; #设置mysql客户端连接服务端时默认使用的端口&gt; &gt; port=3306default-character-set=utf8&gt; 初始化数据库 通过以管理员身份用cmd进入到mysql的安装目录，…\mysql-8.0.13-winx64\bin 目录下。 输入如下命令 初始化：mysqld –initialize –console 执行过程可能需要几分钟，最后会输出一个密码 A temporary password is generated for root@localhost: **，我们只需要记住这些星号的内容就可以了。 安装服务： mysqld –install 如果出现什么Install/Remove of the Service Denied! 的错误，就是因为你没有用管理员身份打开。 启动：mysql：net start mysql 输入密码：mysql -u root -p ** 更改密码： ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘password’; 错误的话 如果在修改密码或者初始化过程中出现问题。运行cmd。在bin目录下运行 net stop mysql 停止运行 mysqld remove 移除 删除掉根目录的data文件夹重新初始化。 基本命令##]]></content>
  </entry>
  <entry>
    <title><![CDATA[四大组件之服务]]></title>
    <url>%2FWWWeb%2FAndroid%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[描述 服务是四大组件之一，适用于取执行那些不需要和用户进行交互并且需要长时间运行的任务。 需要注意的是，服务需要在Manifest.xml中注册并在活动中启动才能正常使用。服务也不是一个单独的进程而是和创建他的那个程序在同一个进程中，当App被杀掉，这个服务也将会被停止，服务中 默认的代码都是执行在主线程中，所以我们不能执行一些耗时的代码，除非我们自己创建一个子线程。 用法 通过Android Studio新建一个Service ，默认继承自Service并在Manifest.xml中注册。 新建一个服务1234567891011121314151617181920212223242526272829public class MyService extends Service &#123; private static final String TAG = "MyService"; public MyService() &#123; &#125; @Override public void onCreate() &#123; super.onCreate(); mContext = getApplicationContext(); Log.d(TAG, "onCreate: "); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand: "); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy: "); &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException("Not yet implemented"); &#125; 启动服务12Intent intent = new Intent(this, MyService.class);startService(intent); 停止服务1stopService(new Intent(this, MyService.class)); 活动和服务进行通信 首先实现一个继承自Binder的类，里面提供想要控制服务的方法。 在自定义服务中添加一个实现Binder的对象，并通过onBind()方法进行返回。 这样活动就可以与服务进行通信了。 实现Binder类 123456789&gt;class MyBinder extends Binder&#123;&gt; void start()&#123;&gt; Log.d(TAG, "start: ");&gt; &#125;&gt; void stop()&#123;&gt; Log.d(TAG, "stop: ");&gt; &#125;&gt; &#125;&gt; 返回Binder实现类的对象。 12345678910111213141516171819202122232425262728293031&gt;public class MyService extends Service &#123;&gt; private static final String TAG = "MyService";&gt; private MyBinder mMyBinder=new MyBinder();&gt; public MyService() &#123;&gt; &#125;&gt; @Override&gt; public void onCreate() &#123;&gt; super.onCreate();&gt; Log.d(TAG, "onCreate: ");&gt; &#125;&gt;&gt; @Override&gt; public int onStartCommand(Intent intent, int flags, int startId) &#123;&gt; Log.d(TAG, "onStartCommand: ");&gt; return super.onStartCommand(intent, flags, startId);&gt; &#125;&gt;&gt; @Override&gt; public void onDestroy() &#123;&gt; super.onDestroy();&gt; Log.d(TAG, "onDestroy: ");&gt; &#125;&gt;&gt; @Override&gt; public IBinder onBind(Intent intent) &#123;&gt; // TODO: Return the communication channel to the service.&gt; return mMyBinder;&gt; &#125;&gt; &gt;&#125;&gt; 在活动中通过建立连接 123456789101112131415&gt;private MyService.MyBinder mMyBinder ;&gt;private ServiceConnection mServiceConnection=new ServiceConnection() &#123;&gt; @Override&gt; public void onServiceConnected(ComponentName name, IBinder service) &#123;&gt; mMyBinder= (MyService.MyBinder) service;&gt; mMyBinder.start();;&gt; mMyBinder.stop();&gt; &#125;&gt;&gt; @Override&gt; public void onServiceDisconnected(ComponentName name) &#123;&gt;&gt; &#125;&gt;&#125;;&gt; 绑定服务 bindService将Service和ServiceConnection进行绑定。最后会回调到Service内部获取到Binder后返回到onServiceConnected方法中。我们就可以获取到服务提供给我们的Binder对象了 123&gt; Intent intent = new Intent(this, MyService.class);&gt; bindService(intent, mServiceConnection, BIND_AUTO_CREATE);&gt; 取消绑定 12&gt; unbindService(mServiceConnection);&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[四大组件之广播]]></title>
    <url>%2FWWWeb%2FAndroid%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[Broadcast 简述 Android应用可以从Android系统和其他Android应用发送或接收广播消息，类似于 发布 - 订阅 设计模式。 例如，Android系统在发生各种系统事件时发送广播，例如系统启动或设备开始充电时。 例如，应用程序还可以发送自定义广播，以通知其他应用程序他们可能感兴趣的内容（例如，已下载了一些新数据）。 应用可以注册以接收特定广播。当发送广播时，系统自动将广播路由到已订阅接收该特定类型广播的应用。 一般而言，广播可以用作跨应用程序和普通用户流程之外的消息传递系统。但是，您必须小心，不要滥用机会响应广播并在后台运行可能导致系统性能降低的作业。 这段是来自谷歌官方的概述。 因为广播接收器中不能执行耗时操作（最多10s 否则将被停止）因此广播接收器更多的是扮演一种打开成都徐其他组件的角色，比如创建一条状态栏通知，或者启动一个服务等。 动态广播 Android 中使用IntentFilter（保存着将要匹配的信息）保存将要发送的广播，用继承自BroadcastReceiver的子类来处理接收到的广播， 通过Activity的registerReceiver()和unregisterReceiver()来对广播接收器进行绑定和解绑。 IntentFilter意图过滤器，这个过滤器中可以保存action,categotry,data的信息，只有信息都相同的时候才能匹配成功。 123456789101112131415161718192021222324252627282930313233343536373839404142//先自定义一个广播接收器public class MyReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. switch (intent.getAction()) &#123; case "android.net.conn.CONNECTIVITY_CHANGE": Toast.makeText(context, "接受到广播 网络变化", Toast.LENGTH_SHORT).show(); break; case "abc": Toast.makeText(context, "接受到广播 abc", Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125;&#125;//在Activity中绑定广播接收器和要接收的广播 protected void onCreate(Bundle savedInstanceState) &#123; ... mIntentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); mIntentFilter.addAction("abc"); //添加将要监听的广播 MyReceiver myReceiver = new MyReceiver(); registerReceiver(myReceiver, mIntentFilter); //绑定广播过滤器和广播接收器 ... sendBroadcast(new Intent("abc")); //网络的变化可以通过手动开关来进行测试，自定义广播可以通过点击触发。 ... &#125;//别忘了最后还需要解除绑定protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(myReceiver); &#125; 为什么要解绑呢？ s 静态广播 新建一个继承自广播接受类，不过需要注意的是这个类需要在Manifest.xml中注册，否则无法实现静态监听， 123&gt; android:enabled="true"&gt; android:exported="true"&gt; 并且这两项都必须设置为true，第一项代表启动这个接收器，第二项属性表示是否接收程序以外的广播。 并在Manifest.xml中 广播的标签内插入IntentFiler标签指示想要接收到什么广播。 不过想要获取某些比较特殊的广播你还需要声明一下权限 比如我们要获取开机启动完成的那个命令就需要声明 12&gt; &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;&gt; 因为静态广播即使程序没有打开也可以被唤醒并接收到广播并作出响应。 123456789101112131415public class MyReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "接到广播" + intent.getAction(), Toast.LENGTH_SHORT).show(); switch (intent.getAction()) &#123; case Intent.ACTION_BOOT_COMPLETED: Toast.makeText(context, "接受到广播 重启", Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125;&#125; 重启后验证了我们代码是正确的。 静态注册和动态注册的区别 在api24级以上，静态注册的广播接收器声明的监听网络状态变化将会不启作用，但是动态注册的仍然可以正常接收广播，这是因为隐式的广播可以启动已注册并监听他的进程，但这些进程大多没什么卵用，还十分的影响用户的体验。所以为了解决这个问题在Android api24里对这些广播做了限制，使接收器不会接收到广播。 动态注册的接收器只有当前应用被启动并且执行到registerReceiver()才能受到广播。 静态注册的接收器应用一被安装到手机上时就已经注册好了，一旦收到想要匹配的广播就可以被激活并处理。 不过有一些广播是无法被静态注册的，比如监听网络的变化，就算你在xml中添加了要匹配的广播也没用，只能动态的注册。 发送广播 不过我们不能发送系统广播，不然将会抛出SecurityException 异常 想要获取到我们发送的自定义广播只需要在静态注册或者动态注册的action中添加”com.example.aaa” 就可以接收并处理这个广播。 12Intent intent = new Intent("com.example.aaa");sendBroadcast(intent); 发送有序广播1sendOrderedBroadcast(intent,null); 新建应用A和应用B，在应用A中发送和接收有序广播，应用B也接收广播。 如果A先获取到并调用了abortBroadcast(); 那么B将接收不到广播。 可以在Manifest.xml中给广播接收器设置优先级，属性为 android:priority=”100” 本地广播 为了避免有的程序疯狂发送垃圾广播或者发送一些携带关键数组的广播被别人捕获而导致的问题，Android引进了一套本地的广播机制，它只能在本应用被发送和接收，接收器也只能接收本应用内的广播这就保证了应用的安全性。 通过下面的代码可以看到本地广播的用法是和动态注册广播接收器的用法是一样的，只不过是通过LocalBroadcastManager来发送，绑定广播。 1234567891011121314151617181920212223242526private LocalBroadcastManager localBroadcastManager;private MyReceiver mMyReceiver;private IntentFilter mIntentFilter1; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); localBroadcastManager = LocalBroadcastManager.getInstance(this); //创建本地广播管理实列 mIntentFilter1 = new IntentFilter(); mIntentFilter1.addAction("com.example.localbroadcast"); mMyReceiver = new MyReceiver(); localBroadcastManager.registerReceiver(mMyReceiver, mIntentFilter1); //绑定广播接收器和过滤器 mTextView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.localbroadcast"); localBroadcastManager.sendBroadcast(intent); //发送广播 &#125; &#125;);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 面试题]]></title>
    <url>%2FWWWeb%2FAndroid%2FAndroid-%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[从简述上摘抄下来，在做一遍。 Activity篇Q: 常规的生命周期 生命周期如图所示。 onCreate在活动第一次被创建的时候调用，可以用来执行一些资源的初始化和布局的加载。 onStart当活动可见的时候被调用。 onResume当活动被加载到前台的时候被调用。 onPause启动另外一个新的活动的时候该方法被调用。 onStop当前的activity不可见时被调用，不能执行一些太耗时的操作，避免影响其他活动的启动。 onRestart返回上一个活动或者重新返回应用界面时被调用。 onDestroy当前活动被销毁时被调用。 Q:onStart()和onResume()/onPause()和onStop()的区别？ onStart()和onStop()是根据当前这个活动是否可见来回调的。 onResume()和onPause()是根据当前这个活动是否在前台来回调的。 Q:Activity A启动另一个Activity B会回调哪些方法？如果Activity B是完全透明呢？如果启动的是一个对话框Activity呢？ 官方文档说明，必须执行完pause之后，新的活动才能被启动。 也可以通过看源码得知不过现在水平不够看不懂。 如果是透明的活动，启动之后旧的活动的onStop不会被回调，因为还可见，如果不可见就会被调用执行。 Q:.谈谈onSaveInstanceState()方法？何时会调用？ asda Q:onSaveInstanceState()与onPause()的区别？ Q:如何避免配置改变时Activity重建？ Q:优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？ Q:.说下Activity的四种启动模式？（有时会出个实际问题来分析返回栈中Activity的情况） Q:谈谈singleTop和singleTask的区别以及应用场景 Q:onNewIntent()调用时机？ Q:了解哪些Activity启动模式的标记位？ Q:如何启动其他应用的Activity？ Q:.Activity的启动过程？ Fragment篇]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Androoid Studio 踩坑记录]]></title>
    <url>%2FWWWeb%2FAndroid-Studio%2FAndrooid-Studio-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1. 快捷键: 快捷键 说明 Ctrl+Q 显示当前调用的方法的参数说明 Ctrl+Shift+F10 编译并运行程序 Ctrl+Alt+L 格式化代码,并自动对齐 Alt+Insert 快速插入get/set方法,以及构造方法等.. 经常需要重写的方法 Ctrl+Insert 快速新建一个类,活动或者服务 Ctrl+Alt+Left/Right 选中往左/右的一个代码单词 就可以不用一个个字母缓慢移动选中了 Ctrl+Alt+O 自动清除导入的包但是没有使用过的 Ctrl+Shift+Space 代码智能提示, 会自动补全 Ctrl+Alt+Space 代码提示,显示可能的构造方法或者接口 Ctrl+Shift+Up/Down 选中的代码向上或者向下移动 F2 快速跳转到代码报错的那一行 2. 故障解决:1. 运行安卓虚拟机出现:Emulator: Could not launch ‘C:\Users\H\AppData\Local\Android\Sdk\emulator/qemu/windows-x86_64/qemu-system-i386.exe’: No such file or directory 进入SDK Manager/SDK Tools 中将Android Emulator选中,点击apply等待下载完毕以后,确定退出,重新启动模拟器就可以运行了. 2.如何重启android studio的虚拟机 长按虚拟机的关机图标会跳出两个选项 (关机/重新启动); 3.怎么看调用一个方法时需要的参数？ 方法1：Ctrl+Q 方法2：Ctrl 然后鼠标移动到相应的方法上面。 2.写代码时，发现某个地方有下划红线怎么快速跳转到这个地方？ 按F2，先跳转到类 再按F2就可以跳转到相应的方法或者代码语句中。 3.想在使用 butterknife的时候，@bindview（R.id.tv） TextView textview 代码格式化以后还在同一行 修改 code style/java 里面的换行和括号，字段注释修改为不换行。]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo部署到GitHub]]></title>
    <url>%2FWWWeb%2FHexo%2FHexo%E9%83%A8%E7%BD%B2%E5%88%B0GitHub%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[外部__config.yml type: git url: 远程仓库的地址 root: 远程仓库的名称 deploy: type: git repo: https://github.com/IChanr/WWWeb.git 远程仓库地址 branch: master 仓库分支，不填写他会自动创建一个 补充完整 部署到git后网页失去样式的解决办法 这里以github为例，如果网站在二级目录里，比如12&gt;https://你的ID.github.io/blog &gt; 则需要将_config.yml里的url修改为12&gt;https://你的ID.github.io/blog &gt; root修改为12&gt;/blog&gt; 如果我们查看访问网页的源码 可以发现指定的css样式的地址只是一个相对的地址，经过上面修改多了一个外层目录blog, 设置为pagers 在github上面点击设置，Source,选择你要的分支保存即可。 他会弹出一个你可以访问的域名。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo界面配置]]></title>
    <url>%2FWWWeb%2FHexo%2FHexo%E7%95%8C%E9%9D%A2%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主题config.yml设置 通过修改主题目录下的__config.yml文件来更改显示效果，以下内容都是修改自内部的那个配置文件 显示动态的背景：移动鼠标会自动连接和断开线条 #Canvas-nestcanvas_nest: false 把里面的false修改为true即可。 设置菜单 想要显示或者隐藏菜单项只需要添加#或者删除 12345678910111213# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: home: / || home about: /about/ || user #tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat## 根目录__config.yml配置 设置侧栏设置头像 avatar: /images/avatar.gif 可以设置站点内也可以设置为外链 不想要显示的话 加一个#就可以了。 avatar: http://pb2rs4133.bkt.clouddn.com/Head.jpg 外部__config.yml设置修改作者名字 author: Cai Han Rong 站点描述 description: 咋咋碎碎念念 集成第三方服务百度统计 登录百度统计获取js?后面的代码 复制粘贴到主题的配置文件中 ，baidu_analytics 这里面。 然后我们就可以通过百度统计到一天之内有多少人访问我们的站点，以及他们的ip 添加设置文章阅读量的功能 https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud 很麻烦上面的方法，不过因为next主题已经集成了这个功能 只需要在这个主题的配置文件里面把 leancloud_visitors: enable: false 把里面的false改成true就行了，当然还有id和key 站内搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb –save 编辑 站点配置文件，新增以下内容到任意位置： 123456&gt; search:&gt; path: search.xml&gt; field: post&gt; format: html&gt; limit: 10000&gt; 编辑 主题配置文件，启用本地搜索功能： 1234&gt; # Local search&gt; local_search:&gt; enable: true&gt; 故障问题点击菜单项出现404或者文件不存在的解决办法 点击分类出现404的时候，是因为本地没有生成相对应的页面。 123456&gt; hexo new page categories&gt; 默认下source/categories/ 文件夹下面创建一个index.md 这个将会是我们等等展示的分类页面，&gt; 需要添加一个属性 ， 输入 type: categories。 不输入的话页面上只显示分类页面但是里面没有具体的分类项。&gt; &gt; 同理 点击菜单上的关于出现404的时候， hexo new page about 即可。&gt; 站内文章链接 _config.yml 中有个permalink的设置。比如你设成 :category/:title/ 路径就是分类/标题，而不是按时间来做路径了，这个是可以随意配置的。 这个里面就可以填写相对链接了，因为他是根据分类和标题来生成目录的。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo环境搭建]]></title>
    <url>%2FWWWeb%2FHexo%2FHexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hexo的安装和配置Git 用于将生成的网站部署到GitHub上面 Node 本地解析.md文件来生成静态网页。 Hexo 通过git bash 选择一个目录进行以下操作。 安装hexo 这是官方的但是下载不了，$ npm install -g hexo-cli 下面的方法可以正常使用。 $ npm install -g cnpm –registry=https://registry.npm.taobao.org$ cnpm install hexo-cli -g 安装完毕以后可以通过 输入 hexo-v 查看hexo的版本和其他的一些信息。 初始化Hexo $ hexo init 安装依赖包 $ npm install 启动hexo hexo server 他会通过node.js生成一个静态网页指定端口让你访问。 至此hexo的配置和安装就完成了。其他的就是写文章和修改主题了。 Hexo目录解释目录： node_modules 存放安装的Hexo的扩展文件。 目录： scaffolds 存放模板的文件，更加具体的可以看这个目录 https://hexo.io/zh-cn/docs/templates.html 大概就是可以生成我们访问网页中的那些导航栏（访问首页，文章，分类的快捷方式） 目录： themes 下载的主题放在这个目录里面，然后在_config.yml中修改使用的主题，到时候生成的网页就是你指定的那种风格了。 目录: source 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 目录： _posts 我们所有写作的文章.md 都保存在这个目录下面，后面.md会被编译成.html文件。 文件: .gitignore git生成的文件,使用git 推送文件到github上时，这个文件里面记录和文件或者目录将不会被上传。 文件： _config.yml 网站的 配置 信息，您可以在此配置大部分的参数。 比如修改主题，网站名称等绝大部分设置。https://hexo.io/zh-cn/docs/configuration 文件： db.json文件： package.json 初始化时自动创建。 应用程序的信息。可以查看hexo的版本以及安装的扩展版本。 文件： package-lock.json https://docs.npmjs.com/files/package-lock.json 通过这个文件可以自动生成和安装hexo的扩展文件。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2FWWWeb%2FHexo%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo clean 清理Hexo的缓存 hexo s –debug 启动本地Hexo站点，并且开启调试模式。 hexo new “pager” 在_posts目录下面创建一个叫pager.md的文件，里面自动帮我满写好了标题和创建事件。 hexo p = hexo publishhexo g = hexo generate 在本地生成html等文件 hexo s = hexo server 在本地启动服务预览，可以查看生成的静态网页是什么样子的。 hexo d = hexo deploy 将本地生成的网页部署到其他地方。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用记录导航]]></title>
    <url>%2FWWWeb%2FHexo%2FHexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[Hexo常用命令 Hexo环境搭建 Hexo界面配置 Hexo部署到GitHub]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FWWWeb%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
