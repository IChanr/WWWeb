<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[笔记摘要C1-Activity的生命周期和启动模式]]></title>
    <url>%2FWWWeb%2FAndroid%2F%E7%AC%94%E8%AE%B0%E6%91%98%E8%A6%81C1-Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[先明确一下： 分析Activity的生命周期和 Activity启动模式 IntentFilter的匹配规则 1. Activity的生命周期1.1常规流程 onCreate() 表示Activity被创建 在这个方法中做一些初始化的工作，比如加载布局、初始化一些需要的数据。 onStart() 表示Activity已经可见但还没在前台，无法和用户进行交互。 onResume() 表示Activity已经可见了并且已经位于前台了，可以和用户进行交互。 onPause() 表示Activity正在停止。 可以进行一些轻量级操作（数据存储、动画的停止等）但不能太耗时，因为会影响新的Activity的打开。 onStop() 表示Activity即将停止，同样不能太过耗时。 onRestart() 表示Activity正在重新启动，一般由Activity由不可见变为可见状态时被调用。 onDestroy() 表示Activity即将被销毁，这是生命周期中的最后一个回调。 可以做一些回收工作和最终的资源释放。 ## ​ Activity-A 启动 Activity-B 启动主题为透明的活动: A.onPause() -&gt;B.onCreate()-&gt;B.onStart()-&gt;B.onResume() A的onStop()方法不会被回调因为他还属于可见状态 在B按Back键返回A: B.onPause()-&gt;A.Restart()-&gt;A.onStart-&gt;A.onResume()-&gt;B.onStop()-&gt;B.onDestroy() 1.2特殊情况：1.2.1系统配置发生改变导致Acitivty被摧毁重建。重建流程 关于onSaveInstanceState和Restor的源码分析 禁止重建Activity AndroidManifest.xml文件中，修改Activity的configChanges属性多个值以|符号来并列，如果系统发生的变化和已经被声明了那么Activity就不会发生重建。具体的填写内容看下面的表格 onRestoreInstanceState和onSaveInstanceState都不会被调用了，会回调这个方法onConfigurationChanged 1.2.2系统资源不足，导致优先级低的Activity被回收2. Activity的启动模式2.1四种模式 模式 作用 standard 标准模式（默认），每启动一个activity都会新建一个新的实例并入栈。 singleTop 栈顶复用，如果要启动的activity已经位于栈顶了，此activity不会重新创建，反而会调用他的onNewIntent方法。可以同传入的Intent参数获取传进来的值。 singleTask 栈内复用，只要即将启动的Activity已经在栈中了，那么不会传创建新的实例，并回调他会onNewIntent方法，并且自己帮我们移除栈内要启动的activity前的所有activity。 singleInstance 单实例模式，加强版的singleTask 使用该启动模式的activity只能单独的位于一个任务栈中。 2.2Intent的标志位2.3总结 也就两种方式 AndroidManiFest.xml中 设置TaskAffinity属性可以设置任务栈的名称； 设置launchMode属性设置启动模式。 需要注意的是TaskAffinity属性不能和包名相同(格式要对)，主要和singleTask启动模式或者allowTaskReparenting属性配对使用。 在AndroidManiFest.xml中使用和在Intent中添加标志位都可以设置activity的启动模式。 其中Intent中设置标志位的优先级比较高。 3.IntentFilter匹配规则3.1显式调用 很简单,直接在Intent里面设置想要启动的Activity。 3.2隐式调用 需要和AndroidManiFest.xml组件中设置的IntentFilter信息匹配（action、category、data） 一个组件如果有多个intent-filter,那只要匹配到其中的一个intent-filter就可以启动该组件。 不管给Intetn设置了多少个action、data、category都要能和intent-filter匹配才能启动成功。 可以不设置category，因为startactivity默认会自己为我们加上。 data由两部分组成mimeType、URI；其中mimeType指媒体类型比如image/jpeg\audio/mpeg4-generic等不同的媒体格式；URI类似访问网站的域名去掉协议那部分，URI的默认值为”content:// “ ，艺术探索上面说file:// 也可以不过在8.0上直接匹配失败，5.0正常使用。 详细的官方文档：https://developer.android.google.cn/guide/components/intents-filters#DataTest 有点痴呆：Intent已经显示调用了我还在intent里面设置action、category等东西，还好改过来了，然后呢，如果Intent-Filter中action、data、category都有的话，除了category不用附加其他的都需要附加否则会造成不匹配，Intent-Filter不匹配的话会报错，那样程序就挂了。 1android.content.ActivityNotFoundException: No Activity found to handle Intent &#123; act=com.example.d &#125; data的完整格式：://:[||] data的匹配过程是渐进的，如果过滤器未设置scheme就忽略其他的URI属性，host未设置则后面的port等都会被忽略掉不会进行匹配 Intent中如果要设置完成的URI不要分开调用setType()和setData(),因为他们会互相清空对方的值，这点可以通过阅读代码验证。应该调用setDataAndType()方法。 AndroidManiFest.xml中一定要设置一个 12&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;&gt; startactivity会自动帮我们附加上该category，如果不设置会导致匹配失败。 标签 匹配规则 action 区分大小写，附加的action都要在过滤器中匹配成功才能启动。 category 同上，只不过默认intent可以不填写，让startactivity自动帮我们填写 data 和action一样。 还有一点很不爽隐式调用失败程序就崩溃了可以用下面的方法解决。 通过PackageManager提供的quertIntentActivityes和resolveActivity方法来查询。 1234567&gt; if (getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY) != null&gt; &amp;&amp; getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY) != null) &#123;&gt; startActivity(intent);&gt; &#125; else &#123;&gt; Log.d(TAG, "onClick: 匹配不到，取消");&gt; &#125;&gt; 主要就是第二个参数，使用这个参数表示只匹配那些在Intent-Filter中声明了 12&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;&gt; 的Activity。 getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY)该方法查询匹配到的Activity列表，不存在他返回一个size为0的列表，不是null和说明的文档不一样getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY)该方法查询并返回匹配到的确切的活动意图，不存在就返回空 这样就可以避免因为隐式调用而导致程序的崩溃了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 学习记录导航页]]></title>
    <url>%2FWWWeb%2FAndroid%2FAndroid-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%AF%BC%E8%88%AA%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[当然还有一些没整理好没发上来。 Android Studio疑难杂症：Androoid Studio 踩坑记录 Android基础：四大组件-服务 四大组件-广播 Android进阶：Android开发艺术探索概要1–Activity的生命周期和启动模式 Android开发艺术探索概要2–IPC机制]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[“日常迷茫”]]></title>
    <url>%2FWWWeb%2Funcategorized%2F%E2%80%9C%E6%97%A5%E5%B8%B8%E8%BF%B7%E8%8C%AB%E2%80%9D%2F</url>
    <content type="text"><![CDATA[2018-11-21 学习IPC 安卓怎么使用Binder驱动程序来进行进程间的通信的？ 需要学习Linux内核怎么加载驱动，jvm怎么调用c/c++的。 2018-11-22 今晚我又看了一晚上的Binder原理的文章，了解了内核空间和用户空间，Linux提供的IPC更多的是从用户空间复制到内核空间再复制到另一个用户空间中，Binder可以从内核空间中映射到用户空间中，所以可以减少一个复制操作。 文章都说Service都注册到ServiceManager中，SM是通过系统初始化生成Binder的。然后他们都是两个不同的进程，那他们怎么通过系统调用Binder是我一直搞不懂的,看了gityuan的文章说（binder涉及的层次跨度比较大,知识量比较广, 建议大家先知道binder是用于进程间通信,有个大致概念就可以.先去学习系统基本知识,等后面有一定功力再进一步深入研究Binder.） 所以我就当作Binder可以跨进程一个神奇类了，Android自动帮我们完成对Binder驱动程序的调用。 Binder的源码的原理我等基本功可以了再来学(c和linux内核学习完成后) 不过我要怎么假设这个Binder呢？ 我只知道bindService后通过ServiceConnection类来返回Binder(Binder由服务注册的时候保存到ServiceManager中的，具体由系统实现)我们通过这个Binder来进行通信。 2018-11-23 开始懂得了，好好学习应用层的知识吧。 2018-11-24 现在学习方向就是跟着Android开发艺术探索学习,遇到不清不楚的都写个文章记录下来.把握流程后面再来深入学习原理.]]></content>
  </entry>
  <entry>
    <title><![CDATA[反射和代理的运用]]></title>
    <url>%2FWWWeb%2Funcategorized%2F%E5%8F%8D%E5%B0%84%E5%92%8C%E4%BB%A3%E7%90%86%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[## 反射： Java核心技术卷1-能够分析类能力的程序称为反射。 具体一点，在我看来就时可以通过反射来获取某个对象的所属类、属性、拥有那些方法等。 Class类 在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识，这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。 保存这些信息的类被称为Class，例如Object类中的getClass()方法将会返回一个Class类型的实例。里面包含这个特定类的属性。 如何获取Class对象？ *.getClass(); *.forName(“包名.类名”)； 类名.class; 12345678&gt;FlectTest flectTest = new FlectTest("name", 18, "boy", "location");&gt;Class c1=flectTest.getClass();&gt;Class c2=Class.forName("reflect.FlectTest");&gt;Class c3=FlectTest.class;&gt;System.out.println(c1);&gt;System.out.println(c2);&gt;System.out.println(c3);&gt; 通过上面的代码可以正确的获取到Class对象。 注意：一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如int不是类，但int.class是一个Class的类型对象。（所有的类都是Object的子类，Object提供了获取当前类的Class对象） 我的理解是：通过Class我们可以获取到类的属性、方法 常用方法 方法 描述 getMethod getMethods 返回一个包含Method对象的数组（包含父类，超类的公有域） getField getFields 返回一个包含Field对象的数组（包含父类，超类的公有域） getConstructor getConstructors 返回一个包含Constructors对象的数组（包含父类，超类的公有域） getDeclaredFields 。。。。私有域也可以获取到，声明为 private 需要注意的是Java的反射机制受制于访问控制，对于私有域只能查看对象有哪些私有域，而不能读取他们的值。 否则将会导致IllegalAccessException，下面的代码验证了这个结果。 1234567891011&gt;FlectTest flectTest = new FlectTest("name", 18, "boy", "location");&gt; Class c=flectTest.getClass();&gt; try &#123;&gt; Field field = c.getDeclaredField("name");&gt; System.out.println(field.get(c));&gt; &#125; catch (NoSuchFieldException e) &#123;&gt; e.printStackTrace();&gt; &#125; catch (IllegalAccessException e) &#123;&gt; e.printStackTrace();&gt; &#125;&gt; 代理： 在不改变已有代码的结构的情况下增强或控制对象的行为。 通过以下代码，实现记录登录时间 123456&gt;package proxy;&gt;&gt;public interface Login &#123;&gt; void startLogin(String userName,String passWord);&gt;&#125;&gt; 1234567891011121314&gt;package proxy;&gt;&gt;public class LoginImpl implements Login &#123;&gt; @Override&gt; public void startLogin(String userName, String passWord) &#123;&gt; if (userName.equals("admin") &amp;&amp; passWord.equals("123456")) &#123;&gt; System.out.println("登录成功");&gt; &#125;else &#123;&gt; System.out.println("登录失败");&gt; &#125;&gt; &#125;&gt;&#125;&gt;&gt; 静态代理：12345678910111213141516package proxy;import java.util.Date;public class LoginStaticProxy implements Login&#123; private LoginImpl mLogin; @Override public void startLogin(String userName, String passWord) &#123; getLoginTime(); mLogin.startLogin("admin","123456"); &#125; public void getLoginTime()&#123; System.out.println(new Date()); &#125;&#125; 通过以上代码，我们只需要在其他地方调用这个代理类就可以实现记录登录时间和进行登录操作了。无需对原有的实现类进行修改，瞬间就美观了很多。 不过也很烦躁啊，如果需要很多种不同的功能，比如我们现在不要获取它的登录时间想要获取它的登录地点，那不就又要建立一个代理类了？ 这个时候动态代理出现了。 动态代理：1234567891011121314151617181920212223package proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Date;public class DynamicProxy implements InvocationHandler &#123; private Object mObject; public DynamicProxy(Object object) &#123; mObject = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; getLoginTime(); Object result=method.invoke(mObject, args); return result; &#125; private void getLoginTime()&#123; System.out.println(new Date()); &#125;&#125; 1234567891011121314package proxy;import java.lang.reflect.Proxy;public class LoginMain &#123; public static void main(String[] args) &#123; DynamicProxy dynamicProxy = new DynamicProxy(login); Login loginProxy = (Login) Proxy.newProxyInstance(login.getClass().getClassLoader(), login.getClass().getInterfaces(), dynamicProxy); loginProxy.startLogin("admin","123456"); &#125;&#125; 通过动态代理，你就不再需要新建很多的代理类了，jdk自带的Proxy类已经自动帮我们生成好了。 而且我们还可以在InvocationHandler中的invoke的方法中对某些要执行的方法进行拦截或者验证，实现新功能。 参考文章：https://my.oschina.net/huangyong/blog/159788 参考书籍：设计模式之禅]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql安装记录]]></title>
    <url>%2FWWWeb%2Funcategorized%2Fmysql%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[下载 先到 https://dev.mysql.com/downloads/mysql/ 下载mysql的压缩包，下载完成以后解压到本地目录下面。 修改配置 …\mysql-8.0.13-winx64\bin 目录下新建一个my.ini配置文件，内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142&gt; &gt; #设置3306端口&gt; port=3306&gt; &gt; &gt; #设置mysql的安装目录&gt; basedir=D:\\WorkLibrary\\mysql-8.0.13-winx64\\mysql-8.0.13-winx64&gt; &gt; ?# 切记此处一定要用双斜杠\\，单斜杠我这里会出错。&gt; &gt; #设置mysql数据库的数据的存放目录&gt; &gt; datadir=D:\\WorkLibrary\\mysql-8.0.13-winx64\\mysql-8.0.13-winx64\\Data?&gt; &gt; ?# 此处同上&gt; &gt; #允许最大连接数&gt; &gt; max_connections=200&gt; &gt; #允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10&gt; &gt; #服务端使用的字符集默认为&gt; &gt; UTF8character-set-server=utf8&gt; &gt; #创建新表时将使用的默认存储引擎&gt; &gt; default-storage-engine=INNODB&gt; &gt; #默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password&gt; &gt; [mysql]&gt; &gt; #设置mysql客户端默认字符集&gt; &gt; default-character-set=utf8[client]&gt; &gt; #设置mysql客户端连接服务端时默认使用的端口&gt; &gt; port=3306default-character-set=utf8&gt; 初始化数据库 通过以管理员身份用cmd进入到mysql的安装目录，…\mysql-8.0.13-winx64\bin 目录下。 输入如下命令 初始化：mysqld –initialize –console 执行过程可能需要几分钟，最后会输出一个密码 A temporary password is generated for root@localhost: **，我们只需要记住这些星号的内容就可以了。 安装服务： mysqld –install 如果出现什么Install/Remove of the Service Denied! 的错误，就是因为你没有用管理员身份打开。 启动：mysql：net start mysql 输入密码：mysql -u root -p ** 更改密码： ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘password’; 错误的话 如果在修改密码或者初始化过程中出现问题。运行cmd。在bin目录下运行 net stop mysql 停止运行 mysqld remove 移除 删除掉根目录的data文件夹重新初始化。 基本命令##]]></content>
  </entry>
  <entry>
    <title><![CDATA[四大组件之服务]]></title>
    <url>%2FWWWeb%2FAndroid%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[描述 服务是四大组件之一，适用于取执行那些不需要和用户进行交互并且需要长时间运行的任务。 需要注意的是，服务需要在Manifest.xml中注册并在活动中启动才能正常使用。服务也不是一个单独的进程而是和创建他的那个程序在同一个进程中，当App被杀掉，这个服务也将会被停止，服务中 默认的代码都是执行在主线程中，所以我们不能执行一些耗时的代码，除非我们自己创建一个子线程。 用法 通过Android Studio新建一个Service ，默认继承自Service并在Manifest.xml中注册。 新建一个服务1234567891011121314151617181920212223242526272829public class MyService extends Service &#123; private static final String TAG = "MyService"; public MyService() &#123; &#125; @Override public void onCreate() &#123; super.onCreate(); mContext = getApplicationContext(); Log.d(TAG, "onCreate: "); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand: "); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy: "); &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException("Not yet implemented"); &#125; 启动服务12Intent intent = new Intent(this, MyService.class);startService(intent); 停止服务1stopService(new Intent(this, MyService.class)); 活动和服务进行通信 首先实现一个继承自Binder的类，里面提供想要控制服务的方法。 在自定义服务中添加一个实现Binder的对象，并通过onBind()方法进行返回。 这样活动就可以与服务进行通信了。 实现Binder类 123456789&gt;class MyBinder extends Binder&#123;&gt; void start()&#123;&gt; Log.d(TAG, "start: ");&gt; &#125;&gt; void stop()&#123;&gt; Log.d(TAG, "stop: ");&gt; &#125;&gt; &#125;&gt; 返回Binder实现类的对象。 12345678910111213141516171819202122232425262728293031&gt;public class MyService extends Service &#123;&gt; private static final String TAG = "MyService";&gt; private MyBinder mMyBinder=new MyBinder();&gt; public MyService() &#123;&gt; &#125;&gt; @Override&gt; public void onCreate() &#123;&gt; super.onCreate();&gt; Log.d(TAG, "onCreate: ");&gt; &#125;&gt;&gt; @Override&gt; public int onStartCommand(Intent intent, int flags, int startId) &#123;&gt; Log.d(TAG, "onStartCommand: ");&gt; return super.onStartCommand(intent, flags, startId);&gt; &#125;&gt;&gt; @Override&gt; public void onDestroy() &#123;&gt; super.onDestroy();&gt; Log.d(TAG, "onDestroy: ");&gt; &#125;&gt;&gt; @Override&gt; public IBinder onBind(Intent intent) &#123;&gt; // TODO: Return the communication channel to the service.&gt; return mMyBinder;&gt; &#125;&gt; &gt;&#125;&gt; 在活动中通过建立连接 123456789101112131415&gt;private MyService.MyBinder mMyBinder ;&gt;private ServiceConnection mServiceConnection=new ServiceConnection() &#123;&gt; @Override&gt; public void onServiceConnected(ComponentName name, IBinder service) &#123;&gt; mMyBinder= (MyService.MyBinder) service;&gt; mMyBinder.start();;&gt; mMyBinder.stop();&gt; &#125;&gt;&gt; @Override&gt; public void onServiceDisconnected(ComponentName name) &#123;&gt;&gt; &#125;&gt;&#125;;&gt; 绑定服务 bindService将Service和ServiceConnection进行绑定。最后会回调到Service内部获取到Binder后返回到onServiceConnected方法中。我们就可以获取到服务提供给我们的Binder对象了 123&gt; Intent intent = new Intent(this, MyService.class);&gt; bindService(intent, mServiceConnection, BIND_AUTO_CREATE);&gt; 取消绑定 12&gt; unbindService(mServiceConnection);&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[四大组件之广播]]></title>
    <url>%2FWWWeb%2FAndroid%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[Broadcast 简述 Android应用可以从Android系统和其他Android应用发送或接收广播消息，类似于 发布 - 订阅 设计模式。 例如，Android系统在发生各种系统事件时发送广播，例如系统启动或设备开始充电时。 例如，应用程序还可以发送自定义广播，以通知其他应用程序他们可能感兴趣的内容（例如，已下载了一些新数据）。 应用可以注册以接收特定广播。当发送广播时，系统自动将广播路由到已订阅接收该特定类型广播的应用。 一般而言，广播可以用作跨应用程序和普通用户流程之外的消息传递系统。但是，您必须小心，不要滥用机会响应广播并在后台运行可能导致系统性能降低的作业。 这段是来自谷歌官方的概述。 因为广播接收器中不能执行耗时操作（最多10s 否则将被停止）因此广播接收器更多的是扮演一种打开成都徐其他组件的角色，比如创建一条状态栏通知，或者启动一个服务等。 动态广播 Android 中使用IntentFilter（保存着将要匹配的信息）保存将要发送的广播，用继承自BroadcastReceiver的子类来处理接收到的广播， 通过Activity的registerReceiver()和unregisterReceiver()来对广播接收器进行绑定和解绑。 IntentFilter意图过滤器，这个过滤器中可以保存action,categotry,data的信息，只有信息都相同的时候才能匹配成功。 123456789101112131415161718192021222324252627282930313233343536373839404142//先自定义一个广播接收器public class MyReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. switch (intent.getAction()) &#123; case "android.net.conn.CONNECTIVITY_CHANGE": Toast.makeText(context, "接受到广播 网络变化", Toast.LENGTH_SHORT).show(); break; case "abc": Toast.makeText(context, "接受到广播 abc", Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125;&#125;//在Activity中绑定广播接收器和要接收的广播 protected void onCreate(Bundle savedInstanceState) &#123; ... mIntentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); mIntentFilter.addAction("abc"); //添加将要监听的广播 MyReceiver myReceiver = new MyReceiver(); registerReceiver(myReceiver, mIntentFilter); //绑定广播过滤器和广播接收器 ... sendBroadcast(new Intent("abc")); //网络的变化可以通过手动开关来进行测试，自定义广播可以通过点击触发。 ... &#125;//别忘了最后还需要解除绑定protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(myReceiver); &#125; 为什么要解绑呢？ s 静态广播 新建一个继承自广播接受类，不过需要注意的是这个类需要在Manifest.xml中注册，否则无法实现静态监听， 123&gt; android:enabled="true"&gt; android:exported="true"&gt; 并且这两项都必须设置为true，第一项代表启动这个接收器，第二项属性表示是否接收程序以外的广播。 并在Manifest.xml中 广播的标签内插入IntentFiler标签指示想要接收到什么广播。 不过想要获取某些比较特殊的广播你还需要声明一下权限 比如我们要获取开机启动完成的那个命令就需要声明 12&gt; &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;&gt; 因为静态广播即使程序没有打开也可以被唤醒并接收到广播并作出响应。 123456789101112131415public class MyReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "接到广播" + intent.getAction(), Toast.LENGTH_SHORT).show(); switch (intent.getAction()) &#123; case Intent.ACTION_BOOT_COMPLETED: Toast.makeText(context, "接受到广播 重启", Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125;&#125; 重启后验证了我们代码是正确的。 静态注册和动态注册的区别 在api24级以上，静态注册的广播接收器声明的监听网络状态变化将会不启作用，但是动态注册的仍然可以正常接收广播，这是因为隐式的广播可以启动已注册并监听他的进程，但这些进程大多没什么卵用，还十分的影响用户的体验。所以为了解决这个问题在Android api24里对这些广播做了限制，使接收器不会接收到广播。 动态注册的接收器只有当前应用被启动并且执行到registerReceiver()才能受到广播。 静态注册的接收器应用一被安装到手机上时就已经注册好了，一旦收到想要匹配的广播就可以被激活并处理。 不过有一些广播是无法被静态注册的，比如监听网络的变化，就算你在xml中添加了要匹配的广播也没用，只能动态的注册。 发送广播 不过我们不能发送系统广播，不然将会抛出SecurityException 异常 想要获取到我们发送的自定义广播只需要在静态注册或者动态注册的action中添加”com.example.aaa” 就可以接收并处理这个广播。 12Intent intent = new Intent("com.example.aaa");sendBroadcast(intent); 发送有序广播1sendOrderedBroadcast(intent,null); 新建应用A和应用B，在应用A中发送和接收有序广播，应用B也接收广播。 如果A先获取到并调用了abortBroadcast(); 那么B将接收不到广播。 可以在Manifest.xml中给广播接收器设置优先级，属性为 android:priority=”100” 本地广播 为了避免有的程序疯狂发送垃圾广播或者发送一些携带关键数组的广播被别人捕获而导致的问题，Android引进了一套本地的广播机制，它只能在本应用被发送和接收，接收器也只能接收本应用内的广播这就保证了应用的安全性。 通过下面的代码可以看到本地广播的用法是和动态注册广播接收器的用法是一样的，只不过是通过LocalBroadcastManager来发送，绑定广播。 1234567891011121314151617181920212223242526private LocalBroadcastManager localBroadcastManager;private MyReceiver mMyReceiver;private IntentFilter mIntentFilter1; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); localBroadcastManager = LocalBroadcastManager.getInstance(this); //创建本地广播管理实列 mIntentFilter1 = new IntentFilter(); mIntentFilter1.addAction("com.example.localbroadcast"); mMyReceiver = new MyReceiver(); localBroadcastManager.registerReceiver(mMyReceiver, mIntentFilter1); //绑定广播接收器和过滤器 mTextView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.localbroadcast"); localBroadcastManager.sendBroadcast(intent); //发送广播 &#125; &#125;);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 面试题]]></title>
    <url>%2FWWWeb%2FAndroid%2FAndroid-%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[从简述上摘抄下来，在做一遍。 Activity篇Q: 常规的生命周期 生命周期如图所示。 onCreate在活动第一次被创建的时候调用，可以用来执行一些资源的初始化和布局的加载。 onStart当活动可见的时候被调用。 onResume当活动被加载到前台的时候被调用。 onPause启动另外一个新的活动的时候该方法被调用。 onStop当前的activity不可见时被调用，不能执行一些太耗时的操作，避免影响其他活动的启动。 onRestart返回上一个活动或者重新返回应用界面时被调用。 onDestroy当前活动被销毁时被调用。 Q:onStart()和onResume()/onPause()和onStop()的区别？ onStart()和onStop()是根据当前这个活动是否可见来回调的。 onResume()和onPause()是根据当前这个活动是否在前台来回调的。 Q:Activity A启动另一个Activity B会回调哪些方法？如果Activity B是完全透明呢？如果启动的是一个对话框Activity呢？ 官方文档说明，必须执行完pause之后，新的活动才能被启动。 也可以通过看源码得知不过现在水平不够看不懂。 如果是透明的活动，启动之后旧的活动的onStop不会被回调，因为还可见，如果不可见就会被调用执行。 Q:.谈谈onSaveInstanceState()方法？何时会调用？ asda Q:onSaveInstanceState()与onPause()的区别？ Q:如何避免配置改变时Activity重建？ Q:优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？ Q:.说下Activity的四种启动模式？（有时会出个实际问题来分析返回栈中Activity的情况） Q:谈谈singleTop和singleTask的区别以及应用场景 Q:onNewIntent()调用时机？ Q:了解哪些Activity启动模式的标记位？ Q:如何启动其他应用的Activity？ Q:.Activity的启动过程？ Fragment篇]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Androoid Studio 踩坑与技巧]]></title>
    <url>%2FWWWeb%2FAndroid-Studio%2FAndrooid-Studio-%E8%B8%A9%E5%9D%91%E4%B8%8E%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1. 快捷键: 快捷键 说明 Ctrl+Q 显示当前调用的方法的参数说明 Ctrl+Shift+F10 编译并运行程序 Ctrl+Alt+L 格式化代码,并自动对齐 Alt+Insert 快速插入get/set方法,以及构造方法等.. 经常需要重写的方法 Ctrl+Insert 快速新建一个类,活动或者服务 Ctrl+Alt+Left/Right 选中往左/右的一个代码单词 就可以不用一个个字母缓慢移动选中了 Ctrl+Alt+O 自动清除导入的包但是没有使用过的 Ctrl+Shift+Space 代码智能提示, 会自动补全 Ctrl+Alt+Space 代码提示,显示可能的构造方法或者接口 Ctrl+Shift+Up/Down 选中的代码向上或者向下移动 F2 快速跳转到代码报错的那一行 2. 故障解决:1. 运行安卓虚拟机出现:Emulator: Could not launch ‘C:\Users\H\AppData\Local\Android\Sdk\emulator/qemu/windows-x86_64/qemu-system-i386.exe’: No such file or directory 进入SDK Manager/SDK Tools 中将Android Emulator选中,点击apply等待下载完毕以后,确定退出,重新启动模拟器就可以运行了. 2.如何重启android studio的虚拟机 长按虚拟机的关机图标会跳出两个选项 (关机/重新启动); 3.怎么看调用一个方法时需要的参数？ 方法1：Ctrl+Q 方法2：Ctrl 然后鼠标移动到相应的方法上面。 4.写代码时，发现某个地方有下划红线怎么快速跳转到这个地方？ 按F2，先跳转到类 再按F2就可以跳转到相应的方法或者代码语句中。 5.想在使用 butterknife的时候，@bindview（R.id.tv） TextView textview 代码格式化以后还在同一行 修改 code style/java 里面的换行和括号，字段注释修改为不换行。 6.常用的ADB命令 ADB文件位于C:\Users\Caiha\AppData\Local\Android\Sdk\platform-tools 6.1基本的命令 启动adb adb start-server 终止adb adb kill-server 安装应用 adb install 进入设置的shell界面 adb shell 多个设备情况下 adb -s &lt;设备序列号&gt; shell 6.2查看命令 获取activity任务栈 adb shell dumpsys activity]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo部署到GitHub]]></title>
    <url>%2FWWWeb%2FHexo%2FHexo%E9%83%A8%E7%BD%B2%E5%88%B0GitHub%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[外部__config.yml type: git url: 远程仓库的地址 root: 远程仓库的名称 deploy: type: git repo: https://github.com/IChanr/WWWeb.git 远程仓库地址 branch: master 仓库分支，不填写他会自动创建一个 补充完整 部署到git后网页失去样式的解决办法 这里以github为例，如果网站在二级目录里，比如12&gt;https://你的ID.github.io/blog &gt; 则需要将_config.yml里的url修改为12&gt;https://你的ID.github.io/blog &gt; root修改为12&gt;/blog&gt; 如果我们查看访问网页的源码 可以发现指定的css样式的地址只是一个相对的地址，经过上面修改多了一个外层目录blog, 设置为pagers 在github上面点击设置，Source,选择你要的分支保存即可。 他会弹出一个你可以访问的域名。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo界面配置]]></title>
    <url>%2FWWWeb%2FHexo%2FHexo%E7%95%8C%E9%9D%A2%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主题config.yml设置 通过修改主题目录下的__config.yml文件来更改显示效果，以下内容都是修改自内部的那个配置文件 显示动态的背景：移动鼠标会自动连接和断开线条 #Canvas-nestcanvas_nest: false 把里面的false修改为true即可。 设置菜单 想要显示或者隐藏菜单项只需要添加#或者删除 12345678910111213# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: home: / || home about: /about/ || user #tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat## 根目录__config.yml配置 设置侧栏设置头像 avatar: /images/avatar.gif 可以设置站点内也可以设置为外链 不想要显示的话 加一个#就可以了。 avatar: http://pb2rs4133.bkt.clouddn.com/Head.jpg 外部__config.yml设置修改作者名字 author: Cai Han Rong 站点描述 description: 咋咋碎碎念念 集成第三方服务百度统计 登录百度统计获取js?后面的代码 复制粘贴到主题的配置文件中 ，baidu_analytics 这里面。 然后我们就可以通过百度统计到一天之内有多少人访问我们的站点，以及他们的ip 添加设置文章阅读量的功能 https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud 很麻烦上面的方法，不过因为next主题已经集成了这个功能 只需要在这个主题的配置文件里面把 leancloud_visitors: enable: false 把里面的false改成true就行了，当然还有id和key 站内搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb –save 编辑 站点配置文件，新增以下内容到任意位置： 123456&gt; search:&gt; path: search.xml&gt; field: post&gt; format: html&gt; limit: 10000&gt; 编辑 主题配置文件，启用本地搜索功能： 1234&gt; # Local search&gt; local_search:&gt; enable: true&gt; 故障问题点击菜单项出现404或者文件不存在的解决办法 点击分类出现404的时候，是因为本地没有生成相对应的页面。 123456&gt; hexo new page categories&gt; 默认下source/categories/ 文件夹下面创建一个index.md 这个将会是我们等等展示的分类页面，&gt; 需要添加一个属性 ， 输入 type: categories。 不输入的话页面上只显示分类页面但是里面没有具体的分类项。&gt; &gt; 同理 点击菜单上的关于出现404的时候， hexo new page about 即可。&gt; 站内文章链接 _config.yml 中有个permalink的设置。比如你设成 :category/:title/ 路径就是分类/标题，而不是按时间来做路径了，这个是可以随意配置的。 这个里面就可以填写相对链接了，因为他是根据分类和标题来生成目录的。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo环境搭建]]></title>
    <url>%2FWWWeb%2FHexo%2FHexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hexo的安装和配置Git 用于将生成的网站部署到GitHub上面 Node 本地解析.md文件来生成静态网页。 Hexo 通过git bash 选择一个目录进行以下操作。 安装hexo 这是官方的但是下载不了，$ npm install -g hexo-cli 下面的方法可以正常使用。 $ npm install -g cnpm –registry=https://registry.npm.taobao.org$ cnpm install hexo-cli -g 安装完毕以后可以通过 输入 hexo-v 查看hexo的版本和其他的一些信息。 初始化Hexo $ hexo init 安装依赖包 $ npm install 启动hexo hexo server 他会通过node.js生成一个静态网页指定端口让你访问。 至此hexo的配置和安装就完成了。其他的就是写文章和修改主题了。 Hexo目录解释目录： node_modules 存放安装的Hexo的扩展文件。 目录： scaffolds 存放模板的文件，更加具体的可以看这个目录 https://hexo.io/zh-cn/docs/templates.html 大概就是可以生成我们访问网页中的那些导航栏（访问首页，文章，分类的快捷方式） 目录： themes 下载的主题放在这个目录里面，然后在_config.yml中修改使用的主题，到时候生成的网页就是你指定的那种风格了。 目录: source 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 目录： _posts 我们所有写作的文章.md 都保存在这个目录下面，后面.md会被编译成.html文件。 文件: .gitignore git生成的文件,使用git 推送文件到github上时，这个文件里面记录和文件或者目录将不会被上传。 文件： _config.yml 网站的 配置 信息，您可以在此配置大部分的参数。 比如修改主题，网站名称等绝大部分设置。https://hexo.io/zh-cn/docs/configuration 文件： db.json文件： package.json 初始化时自动创建。 应用程序的信息。可以查看hexo的版本以及安装的扩展版本。 文件： package-lock.json https://docs.npmjs.com/files/package-lock.json 通过这个文件可以自动生成和安装hexo的扩展文件。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2FWWWeb%2FHexo%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo clean 清理Hexo的缓存 hexo s –debug 启动本地Hexo站点，并且开启调试模式。 hexo new “pager” 在_posts目录下面创建一个叫pager.md的文件，里面自动帮我满写好了标题和创建事件。 hexo p = hexo publishhexo g = hexo generate 在本地生成html等文件 hexo s = hexo server 在本地启动服务预览，可以查看生成的静态网页是什么样子的。 hexo d = hexo deploy 将本地生成的网页部署到其他地方。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用记录导航]]></title>
    <url>%2FWWWeb%2FHexo%2FHexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[Hexo常用命令 Hexo环境搭建 Hexo界面配置 Hexo部署到GitHub]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FWWWeb%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[笔记摘要C2-IPC机制]]></title>
    <url>%2FWWWeb%2FAndroid%2F%E7%AC%94%E8%AE%B0%E6%91%98%E8%A6%81C2-IPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.基础准备知识1.1简单介绍一下什么是IPC IPC是Inter-Process Communication的缩写，含义为进程间通信或者跨进程通信。学习IPC就是为了学习两个进程之间通信的IPC机制。 为了防止不同的程序之间跨界访问不属于自己的内存空间，操作系统加了一些限制在加载程序的时候就分配了内存空间，当非法访问内存空间的时候将会被系统kill掉。这个时候两个不同的进程想要通信就需要IPC这个东西了。 另外Android每一个进程中默认都有一个线程（UI线程），如果执行耗时的IO操作需要在开辟一个子线程，在子线程中执行耗时的业务代码。否则将会造成程序的崩溃。 1.2进程和线程的区别（看码农翻身的文章来记笔记）批处理系统：早期系统因为CPU只有一个并且速度很慢所以只有先把程序加载到内存中来然后让程序A从头到尾执行完毕，然后程序B接着执行。 后来CPU的处理速度大大超过了内存、硬盘的速度。比如程序A需要从硬盘上读取数据的时候，CPU不就空闲了？这个时候就可以让程序B来运行了。并且严格限制每个进程占用CPU的时间。 当CPU执行程序B的代码的时候操作系统会保存好程序A的进程控制块 -PCB （程序执行到什么指令、函数调用到什么层次了、CPU寄存器中的值等等。。），然后加载程序B的进程控制块和程序的代码。当程序A数据读取完毕的时候，就可以重新加载进程控制块和程序然后从中断处继续执行了。 进程的切换也叫上下文切换。 因为CPU的快速运转可以让每个程序执行几十毫秒，在我们的感觉上就是很多进程同时在运行，当然多核CPU出现后就真的可以实现多个程序同时运行了。 进程： 那么程序的代码和他的进程控制块就被称为“进程”。 比如当一个进程在保存大型文件的时候，因为是IO操作所以这个进程会被暂时挂起，给我们的感觉就是界面无响应。等到保存完毕了才可以继续响应我们的操作。 所以引入了线程这个概念（线程共享进程的所有资源如地址空间、全局变量等，同时每个线程也要记住类似进程控制块那样的信息，这样就能像切换进程那样切换线程）。 线程：把进程当成一个资源的容器，里面运行轻量级的进程（线程），线程共享进程的所有资源。线程的切换由内核来实现，因为如果由进程来实现的话，系统还是认为我们只是一个进程，对内部的线程一无所知。当某个线程执行耗时的IO操作的时候这个进程还是会被挂起。所以内核需要知道进程中线程的存在，内核需要维护一个线程表并且负责调度。 Android官方文档说明 1.3 Android怎么开启多进程在AndroidManifest.xml文件中，修改四大组件的process属性。 第一个Activity标签中process属性中以：开头的含义是指要在当前的进程名前附加上当前的包名 第二个标签中，process属性是一个完整的命名方式，不会附加包名信息。 其中进程名以：开头的进程属于当前应用的私有进程，其他应用的组件不可以和它运行在同一个进程中，而进程名不以：开头的进程属于全局进程，其他应用可以通过Share UID方式和它运行在同一个进程中。 应用有相同的Share UID且签名相同就可以互相访问对方的私有数据。 更多的ShareUID可以参考这篇文章https://juejin.im/post/58495255ac502e006c59fc2b 目前Linux的学的不多，所以简单知道一下就可以。 12345678&lt;activity android:name=".Main2Activity" android:label="@string/title_activity_main2" android:process=":jc2" /&gt;&lt;activity android:name=".LoginActivity" android:label="@string/title_activity_login" android:process="com.exemple.caiha.ipc.jc3" /&gt; 可以通过AndroidStudio的Logcat看到确实开启了新的进程，可以看到进程名和进程id。 1.3.1开启多进程的好处因为Android对每一个应用能够使用的最大内存做了限制，不同的设备能使用的内存大小也不一样，所以为了加大应用能够使用的内存空间就可以开启多进程来加大可使用的内存空间。这个时候是在两个进程中了，所以就要用到IPC。 1.3.2模拟内存溢出我模拟了一下内存不够的时候会发生什么事情，可以开辟一个子线程，然后不停的往集合里面写大量的数据，比如Bitmap内存占用会快一点。 系统抛出java.lang.OutOfMemoryError: Failed to allocate a 280364296 byte allocation with 6275072 free bytes and 205MB until OOM, max allowed footprint 193938856, growth limit 402653184，内存溢出，这样我也知道发生内存泄漏的一些原因，比如一些实例占用大量内存得不到释放。 1.3.3开启多进程的坏处Android为每一个进程都分配了一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就造成了在不同的虚拟机中访问同一个类的对象会产生多分副本。 静态成员和单列模式完全失效：因为分配了一个新的独立的虚拟机，所以他们静态成员的单例模式所对应的对象是不同的。 线程同步机制失效：SharedPreferences的可靠性下降：SharedPreferences不支持两个进程同时去执行写操作，它的底层是通过读写xml文件来实现的。所以并发的读写可能会导致数据丢失。 组件之间不能共享数据：组件如果不同的进程，则需要IPC来进行通信。 Application会被多次创建：当一个组件运行在一个新的进程中，系统要先创建一个进程并分配一个虚拟机，所以这个应用又被重新启动了，应用启动又会重新实例一个Application对象。（Application类用的是单列模式），所以一个应用只能有一个Application对象。 所以一个应用开启了多进程在某进程中修改了一个静态类的值是不会影响另一个进程中的静态类的因为他们所在的地址不一样。 1.3.4检验开启多进程会不会重启应用：检验开启多进程确实会重新启动该应用，需要实现一个继承自Application的类、新建几个Activity让他们跳转和设置process属性，然后再AndroidManifest.xml中修改application标签的name属性为.MyApplication，如果manifest标签的package属性没有设置的话，还需要再name属性加上那个类所在的包名。 1234567891011121314151617181920public class MyApplication extends Application &#123; private static final String TAG = "MyApplication"; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate: 创建一次"); ActivityManager am = (ActivityManager) getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; runningApps = am.getRunningAppProcesses(); if (runningApps != null) &#123; for (ActivityManager.RunningAppProcessInfo procInfo : runningApps) &#123; if (procInfo.pid == Process.myPid()) &#123; Log.d(TAG, "onCreate: 进程名为" + procInfo.processName); &#125; &#125; &#125; &#125;&#125; 我在这个应用里面开启了两个进程，加上默认启动的那个进程那 一共就启动了三个进程 运行结果如下图 简单的看一下，就是Application类确实被实例了三次，并且打印出来的进程名不一样。OK验证完成！ 1.4Android的进程架构1.5序列化将对象的状态信息转换为可以存储或传输的形式的过程。 在序列化期间，对象将其当前状态写入到临时或持久性存储区。 以后，可以通过从存储区中读取或反**序列化**对象的状态，重新创建该对象。 1.4.1Serializable、Parcelable接口写一个实现Serializable接口的类,并设置serialVersionUID的值.接下来这个类就可以通过流的形式将自己的对象发送出去,接收方可以重新读取并反序列化重现创建该对象. 需要注意的是,如果设置serialVersionUID的话你会发现也可以成功序列化和反序列化,但是将来如果你的字段或者属性发生了改变那么将无法正常的反序列化,它会抛出一个java.io.InvalidClassException: com.example.caiha.ipc.serialize.TestA; local class incompatible: stream classdesc serialVersionUID = 123, local class serialVersionUID = 6037855109725086113W/System.err: at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:606)类似这样的异常. 所以我们最好还是设置一个初始值避免以后升级这个类而无法反序列化以前的数据.就算以后新添加了一些新的属性或者方法,也可以最大限度的恢复数据不至于程序崩溃. 没有不手动的设置serialVersionUID的值,那么系统会自动的计算当前类的hash值并赋值给serialVersionUID.还有一点就是静态成员变量属于类并不属于对象所以不会参数序列化的过程,用transient关键字标记的成员变量不参与序列化的过程. 1.4.2比较 Serializable Parcelable 平台 Java平台提供的序列化接口 Android提供的序列化接口 原理 将一个对象转换成可存储或可传输的状态，序列化后的对象可以在网络中传输也可以在存储到本地。 将一个对象进行分解，并且分解后的每一部分都是Intent所支持的数据类型。 优缺点 低效，占用大量IO资源，但是使用简单只需要实现指定接口并设置seralersionUID JAVA就会对这个对象进行序列化。 高效，但实现复杂,不过现在Android Studio可以自动帮我们实现。 使用场景 将一个对象转换为可存储或可传输的状态，序列化后的对象可存储到本地也可以通过网络进行传输。 内存的序列化 具体用法 2.Binder（重点） IPC角度:Binder是Android中的一种跨进程通信方式. Android Framework角度: Binder是ServiceManager连接各Manager(ActivityManager,WindowManager)和ManagerService的桥梁. Android应用层: Binder是客户端和服务端进行通信的媒介,当bindService的时候,服务端返回一个包含了服务端业务调用的Binder对象,通过这个BInder对象,客户端就可以获取服务端体哦那个的服务或者数据,这里的服务包括普通服务和基于AIDL的服务. 学习资料：https://zhuanlan.zhihu.com/p/35519585 2.1特性 IPC方式 数据拷贝次数 共享内存 0 Binder 1 Socket/管道/队列 2 Binder的特性 详情 安全性 给每个APP分配一个UID,UID是鉴别 稳定性 基于C/S架构，职责明确，架构清晰 性能 数据只需拷贝一次 2.2原理 详细解释：https://zhuanlan.zhihu.com/p/35519585 简单总结上面的文章： Binder的诞生:Linux内核提供了几种跨进程通信的方式，但是因为安全和性能的关系，Android使用了另一种新的进程通信方式。 为什么要用到IPC：因为进程间是分隔开的，进程A是不能直接访问进程B的数据，要进行进程间的数据通信就需要用到进程间的通信机制。 因为Binder是运行在内核空间的，可以访问受保护的内存空间。我们通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。 大致的进程通信过程为： 首先，一个进程使用 BINDERSETCONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager； Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。 Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。 3. Android中的IPC方式 名称 优点 缺点 使用场景 具体用法 Bundle 简单易用 只能传输Bundle支持的数据类型 四大组件的j进程间通信 文件共享 简单易用 不适合在高并发的场景下使用，并且无法做到进程间的即时通信。 无并发访问情形，交换简单的数据，实时性不高的场景。 AIDL 功能强大，支持一对多并发通信，，支持实时通信。 使用复杂，需要处理好线程同步 一对多通信且有RPC要求 Messenger 功能一般，支持一对多串行通信，支持实时通信。 不能很好的处理高并发情形，不支持RPC,数据通过Message进行传输,因此只能传输Bundle支持的数据类型 低并发的一对多即时通信，无RPC要求，或者无需返回结果的RPC需求 ContentProvider 在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法扩展其他操作。 可以理解为受约束的AIDL，主要提供对数据源的CRUD操作 一对多的进程间的数据交换 Socket 功能强大，可通过网络传输字节流，支持一对多并发实时通信。 实现细节稍微有点繁琐，不支持直接的RPC 网络数据交换 1. Bundle 通过Intent传递Bundle数据，传递的元素除了它支持的基本类型其他的类型要实现Parcelable接口中的方法才可以被序列化并传递。 2.使用文件共享 两个进程通过读写同一个文件来交换数据，同时还可以序列化一个对象到文件中，具体的在Serializable接口中有说明。只不过发生并发读写很容易数据很容易错乱，所以还是少用比较好。 SharedPreferences是Android提供的轻量级存储方案通过键值对的方式来存储数据，底层它采用XML来存储键值对。因为系统对它的读写有一个缓存策略，即内存中有一份SharedPreferences文件的缓存因此在多进程模式下系统对他的读写就变得可靠。阅读Google的API也说了不支持多进程的使用使用SharedPreferences。 用法：https://developer.android.google.cn/training/data-storage/shared-preferences 3.Messenger简介 通过它可以在不同进程中传递Message对象，在Message中放入需要传递的数据就可以通过Messenger来在各进程间传递了。 Messenger是一种轻量级的IPC方案，底层实现是AIDL。 使用 Messenger内部的IBinder是通过Handle传递进来的，通过构造方法可见一斑，它的底层实现还是AIDL只是经过了一点封装。 服务端： 在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler，通过它来创建一个Messenger对象，然后再Service的onBind方法中返回Messenger对象的Binder即可。 客户端： 先绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger对象。如果需要服务端可以回应客户端的话，把当前的Messenger对象赋值给在Message中的 replyTo变量 123456789101112131415161718192021222324252627282930313233343536373839//服务端public class MyService extends Service &#123; private static final String TAG = "MyService"; private class messengerHandle extends Handler &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 1: Log.d(TAG, "handleMessage: 服务端收到客户端发送的请求，附加参数为"+msg.arg1); Messenger messenger=msg.replyTo; Message message=Message.obtain(); message.what=1; message.arg1=123; try &#123; messenger.send(message); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: break; &#125; &#125; &#125; private Messenger mMessenger = new Messenger(new messengerHandle()); public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. return mMessenger.getBinder(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, MyService.class); bindService(intent, mServiceConnection, BIND_AUTO_CREATE); &#125; private static class MessengerHandle extends Handler &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 1: Log.d(TAG, "handleMessage: 客户端接收到服务端的返回数据" + msg.arg1); break; default: break; &#125; &#125; &#125; private Messenger mMessenger; private Messenger mMessenger2 = new Messenger(new MessengerHandle()); private ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mMessenger = new Messenger(service); Message message = new Message(); message.what = 1; message.arg1 = 369; message.replyTo = mMessenger2; try &#123; mMessenger.send(message); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; 12345&lt;service android:process=":other" android:name=".MyService" android:enabled="true" android:exported="true"&gt;&lt;/service&gt; 通过上面代码测试，确实能够实现进程间的通信。 4.使用AIDL1. 创建 .aidl 文件 AIDL 使用简单语法，使您能通过可带参数和返回值的一个或多个方法来声明接口。 参数和返回值可以是任意类型，甚至可以是其他 AIDL 生成的接口。 您必须使用 Java 编程语言构建 .aidl 文件。每个 .aidl 文件都必须定义单个接口，并且只需包含接口声明和方法签名。 默认情况下，AIDL 支持下列数据类型： Java 编程语言中的所有原语类型（如 int、long、char、boolean 等等）String、CharSequence、List、Map，其中集合中的子元素需要是以上的基本元素。 *概况一下: 就是除了以上的基础类型 集合内部的子元素想要是其他类型想要在AIDL中使用的话，需要先建立一个与类名相同的AIDL文件，并以 parcelable 类名；来声明，比如 parcelable Book; 然后在要使用的AIDL文件中 import 包名.aidl声明类型的文件名 2.实现接口 当您开发应用时，Android SDK 工具会生成一个以 .aidl 文件命名的 .java 接口文件。生成的接口包括一个名为 Stub 的子类，这个子类是其父接口（例如，YourInterface.Stub）的抽象实现，用于声明 .aidl 文件中的所有方法。 3.分析 写完.aidl文件后重新构建该项目，Android SDK会在gen目录下自动生成一个和 .aidl 同名的 .java文件，就分析这个类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt; public interface IBookManager extends android.os.IInterface &#123;&gt; &gt; //内部类Stub 实际上就是一个Binder类，当客户端和服务端处于同以进程时不会走transact过程，反之就会走。&gt; public static abstract class Stub extends android.os.Binder implements com.example.caiha.ipc5.IBookManager &#123;&gt; //标识符，Binder的唯一标识&gt; private static final java.lang.String DESCRIPTOR = "com.example.caiha.ipc5.IBookManager";&gt; &gt; public Stub() &#123;&#125;&gt; //用于将服务端的Binder转换成客户端所需的AIDL接口类型对象，这种过程时区分进程的，C/S在同一进程下返回的时服务端的Stub对象本身，反之返回封装后的Stub.proxy对象。（分析一下方法就知道了。）&gt; public static IBookManager asInterface(android.os.IBinder obj) &#123;&#125;&gt; &gt; //用于返回当前Binder对象。&gt; public android.os.IBinder asBinder() &#123;&#125;&gt; &gt; //该方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法处理。服务端通过code来确定服务端请求哪个方法，从data中获取目标方法所需的参数。reply用于写入将要返回给客户端的数据。 最后如果返回false的话，客户端的请求会失败，可以利用这个特性来做一些权限验证。&gt; public boolean onTransact(int code, Parcel data, Parcel reply, int flags)&#123;&#125;&gt; &gt; private static class Proxy implements com.example.caiha.ipc5.IBookManager &#123;&gt; private android.os.IBinder mRemote;&gt; &gt; Proxy(android.os.IBinder remote) &#123;&#125;&gt; &gt; public android.os.IBinder asBinder() &#123;&#125;&gt; &gt; public java.lang.String getInterfaceDescriptor() &#123;&#125;&gt; &gt; &gt; //外部两个方法的具体实现，通过父类Binder的transact方法调用到Binder的onTransact方法。至此整个流程我就都知道了。&gt; public void addBook(com.example.caiha.ipc5.aaa.Book book) &#123;&#125;&gt; &gt; public java.util.List&lt;com.example.caiha.ipc5.aaa.Book&gt; getBookList() &#123;&#125;&gt; &gt; //两个两个int常量可以用来标识在transact过程中客户端到底请求的是哪个方法。&gt; static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);&gt; static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);&gt; &#125;&gt; &gt; &gt; //下面声明的两个方法是在我们的aidl文件中定义的。&gt; public void addBook(com.example.caiha.ipc5.aaa.Book book) throws android.os.RemoteException;&gt; &gt; public java.util.List&lt;com.example.caiha.ipc5.aaa.Book&gt; getBookList() throws android.os.RemoteException;&gt; &#125;&gt; 以上代码也可以手动写出来，AIDL不过是简化了我们的流程而已。 4.给Binder设置死亡代理 1234567891011&gt; private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient() &#123;&gt; @Override&gt; public void binderDied() &#123;&gt; Log.w(TAG, "啊 服务端死掉了: ");&gt; Binder对象.asBinder().unlinkToDeath(mBinderPoolDeathRecipient, 0);&gt; Binder对象 = null;&gt; connectBinderPoolService();&gt; //当服务端的出现以外停止的时候该方法会被调用，客户可以在这里进行重连的处理。&gt; &#125;&gt; &#125;;&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
</search>
